[["index.html", "Visualising WRC Telemetry Data With R A RallyDataJunkie Recipe Book Preface", " Visualising WRC Telemetry Data With R A RallyDataJunkie Recipe Book Tony Hirst Last generated on 14 October, 2021 Preface A recipe guide to visualising WRC car telemetry data using the R programming language. Based on analysis of telemetry data files downloaded from the WRC website. To discuss / critique / comment on these analyses, please use the discussion forum. For a guide to visualising stages, see Visualising WRC Rally Stages. For a guide to visualising rally timing and results data, see Visualising WRC Rally Results. This report is unofficial and is not associated in any way with the Fédération Internationale de l’Automobile (FIA) or WRC Promoter GmbH. "],["introducing-wrc-telemetry.html", "1 Introducing WRC Telemetry", " 1 Introducing WRC Telemetry Whilst a rally is in progress, a limited amount of telemetry is available from the live mapping facility. This comes in the form of GPS location data for each vehicle at a low sample rate. This data can be collected and used in real time to give us a means of identifying approximately where on a stage a driver might have lost time compared to another driver. Essentially, we can use the data to create effective split points every 200m or so along a rally stage, rather than every 5km. In addition, we can use the data to identify whether a car has stopped on a road section, and for how long. More detailed telemetry data can be found on the WRC+ website several hours after a stage has run. This is at a much higher sample rate and includes speed, RPM, throttle and brake data. This allows us to make basic comparisons of drivers’ actual performance on a stage at the end of each day of running. "],["loading-the-live-telemetry-route-data.html", "2 Loading the Live Telemetry Route Data 2.1 Spatial Utilities 2.2 Loading in the Telemetry Route Data 2.3 Preparing the Telemetry Route Data 2.4 Visual Preview of the Telemetry Route Data", " 2 Loading the Live Telemetry Route Data The examples provided utilise data that has already been downloaded. 2.1 Spatial Utilities The GPS data is provided as a set of latitude and longitude co-ordinates. For various forms of analysis, such as calculating and comparing distance in meters, we need to map from the latitude/longitude co-ordinate system to a projection such as UTM (Universal transverse Mercator). The following function identifies the correct UTM region for managing the conversion. library(sf) lonlat2UTM_hemisphere &lt;- function(lonlat) { ifelse(lonlat[1] &gt; 0, &quot;north&quot;, &quot;south&quot;) } lonlat2UTMzone = function(lonlat) { utm = (floor((lonlat[1] + 180) / 6) %% 60) + 1 if(lonlat[2] &gt; 0) { utm + 32600 } else{ utm + 32700 } } Create a simple latitude/longitude CRS (co-ordinate reference system) string to specify the CRS for use with simple lat/long data: latlon_crs = 4326 We can also set the timezone. This might be done explicitly, or from a location co-ordinate using the R lutz package. timezone = &quot;Europe/Helsinki&quot; 2.2 Loading in the Telemetry Route Data The data is available in the form of a simple CSV data file. The data is presented in a reverse chronological order, but it is more natural for us to present it in chronological (increasing time) order. telem_df_min = read.csv(file.path(path, &quot;df_telemetrydata_SS7_Evans.csv&quot;) ) %&gt;% map_df(rev) kable(head(telem_df_min), format = &quot;html&quot;) %&gt;% kable_styling() %&gt;% kableExtra::scroll_box(width = &quot;100%&quot;) X accx accy altitude brk driverid gear heading kms lat lon name rpm speed status throttle track utx X_rally_stageid X_carentryid X_telemetryID X_name 1870 0 0 0 0 NA 0 144 0.6 61.83077 25.12109 33 0 166 Competing 0 NA 1.633164e+12 bcc5537d-d28a-40af-ba86-95dad7fb9cd1 b185c5df-8115-40cf-bd81-566f016f6bf5 /a3f5f3f5-3fb0-42ab-af90-24d91c0493d0/ss07eva_telemetry_js/js Evans 1869 0 0 0 0 NA 0 150 0.7 61.82966 25.12240 33 0 140 Competing 0 NA 1.633164e+12 bcc5537d-d28a-40af-ba86-95dad7fb9cd1 b185c5df-8115-40cf-bd81-566f016f6bf5 /a3f5f3f5-3fb0-42ab-af90-24d91c0493d0/ss07eva_telemetry_js/js Evans 1868 0 0 0 0 NA 0 172 0.8 61.82912 25.12291 33 0 60 Competing 0 NA 1.633164e+12 bcc5537d-d28a-40af-ba86-95dad7fb9cd1 b185c5df-8115-40cf-bd81-566f016f6bf5 /a3f5f3f5-3fb0-42ab-af90-24d91c0493d0/ss07eva_telemetry_js/js Evans 1867 0 0 0 0 NA 0 220 0.9 61.82856 25.12200 33 0 107 Competing 0 NA 1.633164e+12 bcc5537d-d28a-40af-ba86-95dad7fb9cd1 b185c5df-8115-40cf-bd81-566f016f6bf5 /a3f5f3f5-3fb0-42ab-af90-24d91c0493d0/ss07eva_telemetry_js/js Evans 1866 0 0 0 0 NA 0 210 1.0 61.82766 25.12067 33 0 149 Competing 0 NA 1.633164e+12 bcc5537d-d28a-40af-ba86-95dad7fb9cd1 b185c5df-8115-40cf-bd81-566f016f6bf5 /a3f5f3f5-3fb0-42ab-af90-24d91c0493d0/ss07eva_telemetry_js/js Evans 1865 0 0 0 0 NA 0 208 1.1 61.82662 25.11919 33 0 159 Competing 0 NA 1.633164e+12 bcc5537d-d28a-40af-ba86-95dad7fb9cd1 b185c5df-8115-40cf-bd81-566f016f6bf5 /a3f5f3f5-3fb0-42ab-af90-24d91c0493d0/ss07eva_telemetry_js/js Evans We note quite a few null columns in there, so let’s clean those out of the dataframe too: telem_df_min = telem_df_min %&gt;% select(-c(accx, accy, altitude, brk, driverid, gear, rpm, throttle, track)) %&gt;% select(-c(X_rally_stageid, X_carentryid, X_telemetryID)) kable(head(telem_df_min), format = &quot;html&quot;) %&gt;% kable_styling() %&gt;% kableExtra::scroll_box(width = &quot;100%&quot;) X heading kms lat lon name speed status utx X_name 1870 144 0.6 61.83077 25.12109 33 166 Competing 1.633164e+12 Evans 1869 150 0.7 61.82966 25.12240 33 140 Competing 1.633164e+12 Evans 1868 172 0.8 61.82912 25.12291 33 60 Competing 1.633164e+12 Evans 1867 220 0.9 61.82856 25.12200 33 107 Competing 1.633164e+12 Evans 1866 210 1.0 61.82766 25.12067 33 149 Competing 1.633164e+12 Evans 1865 208 1.1 61.82662 25.11919 33 159 Competing 1.633164e+12 Evans 2.3 Preparing the Telemetry Route Data We can perform a small amount of cleaning on the data to remove any rows where there are missing latitude or longitude values before before generating a spatial features data object with a column containing the geometry information with the lat/long co-ordinate reference system (CRS) specified. To better manage the timing components, we can cast the universal time stamp (in milliseconds) to a datetime stamp, ensuring we also set the correct time zone along the way. A delta_s columns is also used to capture the time difference (in seconds) between sample points. X heading kms name speed status utx X_name geometry delta_s utc 1870 144 0.6 33 166 Competing 1.633164e+12 Evans POINT (25.12109 61.83077) 0.0 2021-10-02 11:37:23 1869 150 0.7 33 140 Competing 1.633164e+12 Evans POINT (25.1224 61.82966) 3.2 2021-10-02 11:37:26 1868 172 0.8 33 60 Competing 1.633164e+12 Evans POINT (25.12291 61.82912) 6.4 2021-10-02 11:37:30 1867 220 0.9 33 107 Competing 1.633164e+12 Evans POINT (25.122 61.82856) 9.6 2021-10-02 11:37:33 1866 210 1.0 33 149 Competing 1.633164e+12 Evans POINT (25.12067 61.82766) 12.8 2021-10-02 11:37:36 1865 208 1.1 33 159 Competing 1.633164e+12 Evans POINT (25.11919 61.82662) 16.0 2021-10-02 11:37:39 For convenience, let’s also generate a UTM projection of this spatial features dataframe: # Generate a UTM projection of the route telemetry telem_df_min_utm = telem_df_min %&gt;% st_transform(crs = st_crs(utm_proj4_string)) 2.4 Visual Preview of the Telemetry Route Data We can preview the route on an interactive map using the leaflet package, casting the route data to a set of paired co-ordinates: library(leaflet) tmp_route &lt;- telem_df_min %&gt;% st_coordinates() leaflet(tmp_route) %&gt;% addProviderTiles(&quot;OpenTopoMap&quot;, group = &quot;OSM&quot;) %&gt;% addPolylines(color = &quot;red&quot;, weight = 5) The “live” telemetry includes the road section data. To access the data for just the stage we need to filter it somehow. There are two ways we might do this: based on time: if we know the stage start time for the driver, and their stage time, we can filter the data based on timestamps; based on location: if we have route data for the stage, we can create a buffered area around the stage route, and then filter telemetry data based on points that lay inside that buffered area. "],["using-official-route-data.html", "3 Using Official Route Data 3.1 Loading Official Stage Route Data 3.2 Comparing Stage Route Telemetry and the Stage Route", " 3 Using Official Route Data To make most effective use of the telemetry data, we want to be able to identify the stage section data as well as the road section data. We can use the official stage route to filter data points from a set of location data that includes road section locations to just those points that lay along a route. # Path to the route telemetry data path = &quot;../../wrcplus/notebooks/2021_secto_Rally_Finland&quot; geojson_filename = &quot;data/finland_2021.geojson&quot; For more information on analysing rally stage routes, see Visualising WRC Rally Stages With rayshader and R. 3.1 Loading Official Stage Route Data Let’s load in some route data: geojson_sf = sf::st_read(geojson_filename) ## Reading layer `finland_2021&#39; from data source ## `/Users/tonyhirst/Documents/GitHub/visualising-wrc-telemetry-data/src/data/finland_2021.geojson&#39; ## using driver `GeoJSON&#39; ## Simple feature collection with 13 features and 2 fields ## Geometry type: GEOMETRY ## Dimension: XYZ ## Bounding box: xmin: 24.86575 ymin: 61.52393 xmax: 26.20794 ymax: 62.39946 ## z_range: zmin: 0 zmax: 148.839 ## Geodetic CRS: WGS 84 Let’s also clean the data a little by removing the reference to the Z dimension, making a note of original co-ordinate reference scheme, and generating references to the route in both latlong and UTM forms: stage_route = geojson_sf[7,] %&gt;% st_zm() # Grab a copy of the original projection original_crs = st_crs(stage_route) # Find the UTM zone for a sample a point on the route crs_zone = lonlat2UTMzone(c(st_coordinates(stage_route)[1,1], st_coordinates(stage_route)[1,2])) # Create the projection string utm_proj4_string = st_crs(crs_zone)$proj4string #&quot;+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs&quot; # units in meters e.g. https://epsg.io/32632 # Transform the route projection stage_route_utm = st_transform(stage_route, crs = st_crs(utm_proj4_string)) 3.2 Comparing Stage Route Telemetry and the Stage Route Let’s plot the telemetry data on a map, and then compare it to the stage route data: leaflet() %&gt;% addProviderTiles(&quot;OpenTopoMap&quot;, group = &quot;OSM&quot;) %&gt;% addPolylines(data=tmp_route, color = &quot;red&quot;, weight = 5) %&gt;% addPolylines(data=stage_route, color = &quot;black&quot;, weight = 3) If you look closely at the map, you will see that the stage route trace (in black) closely follows the road indicated on the map, but the lower resolution route telemetry data (the red line) only falls at occasional points along it; a straight line connects the sample points. "],["telemetry-data-along-a-stage.html", "4 Telemetry Data Along a Stage 4.1 Finding Points on the Route Closest to the Telemetry Data Locations", " 4 Telemetry Data Along a Stage We can filter the telemetry data to just the data points that lay on the route by creating a buffered area around the route and then “cropping” the telemetry route data to just the data that fulls within that region. Let’s create a buffered area 100m wide around the route: # Generate buffered routes in UTM and longlat projections buffer_margin_100m = units::set_units(100, m) buffered_route_utm = st_buffer(stage_route_utm, buffer_margin_100m) buffered_route = st_transform(buffered_route_utm, original_crs) leaflet(buffered_route) %&gt;% addProviderTiles(&quot;OpenTopoMap&quot;, group = &quot;OSM&quot;) %&gt;% addPolylines(color = &quot;red&quot;, weight = 2) To simplify distance calculations, where we are likely to want to work in units of meters, generate a UTM projection of the route telemetry data: # Also generate a UTM projection of the minimal route telemetry route_telem_utm = st_transform(route_telem, crs = st_crs(utm_proj4_string)) Let’s see how it looks: X accx accy altitude brk driverid gear heading kms name rpm speed status throttle track utx X_rally_stageid X_carentryid X_telemetryID X_name delta utc geometry 1870 0 0 0 0 NA 0 144 0.6 33 0 166 Competing 0 NA 1.633164e+12 bcc5537d-d28a-40af-ba86-95dad7fb9cd1 b185c5df-8115-40cf-bd81-566f016f6bf5 /a3f5f3f5-3fb0-42ab-af90-24d91c0493d0/ss07eva_telemetry_js/js Evans 0 2021-10-02 08:37:23 POINT (25.12109 61.83077) 1869 0 0 0 0 NA 0 150 0.7 33 0 140 Competing 0 NA 1.633164e+12 bcc5537d-d28a-40af-ba86-95dad7fb9cd1 b185c5df-8115-40cf-bd81-566f016f6bf5 /a3f5f3f5-3fb0-42ab-af90-24d91c0493d0/ss07eva_telemetry_js/js Evans 3200 2021-10-02 08:37:26 POINT (25.1224 61.82966) 1868 0 0 0 0 NA 0 172 0.8 33 0 60 Competing 0 NA 1.633164e+12 bcc5537d-d28a-40af-ba86-95dad7fb9cd1 b185c5df-8115-40cf-bd81-566f016f6bf5 /a3f5f3f5-3fb0-42ab-af90-24d91c0493d0/ss07eva_telemetry_js/js Evans 6400 2021-10-02 08:37:30 POINT (25.12291 61.82912) 1867 0 0 0 0 NA 0 220 0.9 33 0 107 Competing 0 NA 1.633164e+12 bcc5537d-d28a-40af-ba86-95dad7fb9cd1 b185c5df-8115-40cf-bd81-566f016f6bf5 /a3f5f3f5-3fb0-42ab-af90-24d91c0493d0/ss07eva_telemetry_js/js Evans 9600 2021-10-02 08:37:33 POINT (25.122 61.82856) 1866 0 0 0 0 NA 0 210 1.0 33 0 149 Competing 0 NA 1.633164e+12 bcc5537d-d28a-40af-ba86-95dad7fb9cd1 b185c5df-8115-40cf-bd81-566f016f6bf5 /a3f5f3f5-3fb0-42ab-af90-24d91c0493d0/ss07eva_telemetry_js/js Evans 12800 2021-10-02 08:37:36 POINT (25.12067 61.82766) 1865 0 0 0 0 NA 0 208 1.1 33 0 159 Competing 0 NA 1.633164e+12 bcc5537d-d28a-40af-ba86-95dad7fb9cd1 b185c5df-8115-40cf-bd81-566f016f6bf5 /a3f5f3f5-3fb0-42ab-af90-24d91c0493d0/ss07eva_telemetry_js/js Evans 16000 2021-10-02 08:37:39 POINT (25.11919 61.82662) We can now find the intersection of the buffered stage route and the original telemetry spatial features dataframe. The st_intersects() function prefers a UTM projection, so let’s use that: #Find the intersecting points route_telem_intersect = st_intersects(buffered_route_utm, telem_df_min_utm) # And then filter on those points # Also nullify the Z dimension route_telem = telem_df_min[route_telem_intersect[[1]],] %&gt;% st_zm() Let’s preview the first few rows of that data: X heading kms name speed status utx X_name geometry delta_s utc 1870 144 0.6 33 166 Competing 1.633164e+12 Evans POINT (25.12109 61.83077) 0.0 2021-10-02 11:37:23 1869 150 0.7 33 140 Competing 1.633164e+12 Evans POINT (25.1224 61.82966) 3.2 2021-10-02 11:37:26 1868 172 0.8 33 60 Competing 1.633164e+12 Evans POINT (25.12291 61.82912) 6.4 2021-10-02 11:37:30 1867 220 0.9 33 107 Competing 1.633164e+12 Evans POINT (25.122 61.82856) 9.6 2021-10-02 11:37:33 1866 210 1.0 33 149 Competing 1.633164e+12 Evans POINT (25.12067 61.82766) 12.8 2021-10-02 11:37:36 1865 208 1.1 33 159 Competing 1.633164e+12 Evans POINT (25.11919 61.82662) 16.0 2021-10-02 11:37:39 If we assume that the kms column is the distance into stage, we see that it appears that we are missing data from the start of the run? The datetime would also suggest that we may be missing some samples from the start of the run, because start times typically start precisely on the minute. But at least we have something! If we now plot the resulting telemetry data points, we see have limited our selection to just the sample points that fall within the buffered stage route area: leaflet(route_telem ) %&gt;% addProviderTiles(&quot;OpenTopoMap&quot;, group = &quot;OSM&quot;) %&gt;% addCircleMarkers() 4.1 Finding Points on the Route Closest to the Telemetry Data Locations Locating telemetry data along a stage us useful, but how we might start to use that to make comparisons between drivers? If we know the time of day when a drive starts a stage, we can find the difference between the telemetry sample time and the start time to get an elapsed duration into the stage. But even so: how do we know where in a stage a car is? When split times are recorded, we know exactly where the car was at that point in time: it was at the split point location. So how might we determine where a car is on a route that acts as a fair basis for comparison. One way is to create notional split points at known distances along the actual route. The rgeos::gProject() function finds the points along the stage route that are nearest to the telemetry route points. Specifically, the function returns the distance along the route of the point on the route nearest to a provided location. This means that we can provide a set of points, such as a telemetry sample location points, and get the distance of a point along the route that is closest to the sample point location. One thing to note about the rgeos package is that it works with Spatial (sp) objects rather than spatial features (sf) objects, we so need to manage a conversion from one object type to the other in order to call the :gProject() function. If we also use UTM co-ordinates, the distance along the route is given in meters: min_pois_utm = st_sfc(st_multipoint(st_coordinates(route_telem_utm)), crs=st_crs(route_telem_utm)) # Handle the conversion from sf to sp objects # Generate a list of points from a multipoint # Via: https://github.com/r-spatial/sf/issues/114 min_pois_points_utm = st_cast(x = min_pois_utm, to = &quot;POINT&quot;) min_pois_points_utm_sp = as(min_pois_points_utm, &#39;Spatial&#39;) # Find the distance along the route of the point on the route # nearest to each telemetry sample dist_points = rgeos::gProject(as(stage_route_utm, &quot;Spatial&quot;), min_pois_points_utm_sp, normalized = FALSE) zz = as.data.frame(dist_points) # Add the distance into stage for each point route_telem_utm$dist = dist_points How does the data look now? X accx accy altitude brk driverid gear heading kms name rpm speed status throttle track utx X_rally_stageid X_carentryid X_telemetryID X_name delta utc geometry dist 1870 0 0 0 0 NA 0 144 0.6 33 0 166 Competing 0 NA 1.633164e+12 bcc5537d-d28a-40af-ba86-95dad7fb9cd1 b185c5df-8115-40cf-bd81-566f016f6bf5 /a3f5f3f5-3fb0-42ab-af90-24d91c0493d0/ss07eva_telemetry_js/js Evans 0 2021-10-02 08:37:23 POINT (401052.2 6856758) 531.9830 1869 0 0 0 0 NA 0 150 0.7 33 0 140 Competing 0 NA 1.633164e+12 bcc5537d-d28a-40af-ba86-95dad7fb9cd1 b185c5df-8115-40cf-bd81-566f016f6bf5 /a3f5f3f5-3fb0-42ab-af90-24d91c0493d0/ss07eva_telemetry_js/js Evans 3200 2021-10-02 08:37:26 POINT (401117.6 6856633) 673.7129 1868 0 0 0 0 NA 0 172 0.8 33 0 60 Competing 0 NA 1.633164e+12 bcc5537d-d28a-40af-ba86-95dad7fb9cd1 b185c5df-8115-40cf-bd81-566f016f6bf5 /a3f5f3f5-3fb0-42ab-af90-24d91c0493d0/ss07eva_telemetry_js/js Evans 6400 2021-10-02 08:37:30 POINT (401142.7 6856572) 746.9263 1867 0 0 0 0 NA 0 220 0.9 33 0 107 Competing 0 NA 1.633164e+12 bcc5537d-d28a-40af-ba86-95dad7fb9cd1 b185c5df-8115-40cf-bd81-566f016f6bf5 /a3f5f3f5-3fb0-42ab-af90-24d91c0493d0/ss07eva_telemetry_js/js Evans 9600 2021-10-02 08:37:33 POINT (401093 6856511) 825.5652 1866 0 0 0 0 NA 0 210 1.0 33 0 149 Competing 0 NA 1.633164e+12 bcc5537d-d28a-40af-ba86-95dad7fb9cd1 b185c5df-8115-40cf-bd81-566f016f6bf5 /a3f5f3f5-3fb0-42ab-af90-24d91c0493d0/ss07eva_telemetry_js/js Evans 12800 2021-10-02 08:37:36 POINT (401020.1 6856413) 947.9104 1865 0 0 0 0 NA 0 208 1.1 33 0 159 Competing 0 NA 1.633164e+12 bcc5537d-d28a-40af-ba86-95dad7fb9cd1 b185c5df-8115-40cf-bd81-566f016f6bf5 /a3f5f3f5-3fb0-42ab-af90-24d91c0493d0/ss07eva_telemetry_js/js Evans 16000 2021-10-02 08:37:39 POINT (400938.8 6856299) 1088.1680 We might thinks of each of these points as notional split points at particular distances along the route. it is also worth noting that the rgeos::gInterpolate() function complements rgeos::gProject() by providing a function that can also return a location a specified distance along a line: sample_point_sp_utm = rgeos::gInterpolate(as(stage_route_utm, &quot;Spatial&quot;), 5000, # Distance along route in meters normalized = FALSE) # We can convert back from an sp to an sf object: sample_point_sf_utm = st_as_sf(sample_point_sp_utm) # And also convert back to a latlong reference system sample_point_sf = sample_point_sf_utm %&gt;% st_transform(crs = st_crs(latlon_crs)) Let’s see that point, 5km along the route: leaflet() %&gt;% addProviderTiles(&quot;OpenTopoMap&quot;, group = &quot;OSM&quot;) %&gt;% addPolylines(data=stage_route, color = &quot;black&quot;, weight = 3) %&gt;% addMarkers(data=sample_point_sf) "],["plotting-locations-a-certain-time-into-the-stage.html", "5 Plotting Locations a Certain Time Into the Stage 5.1 Find the Stage Telemetry Time Series Origin 5.2 Plotting the Stage Telemetry Time Series", " 5 Plotting Locations a Certain Time Into the Stage In order to calculate the time into stage, we need to set the time series origin somehow. If we have a telemetry data point recorded at the start stage start (location wise) when the light goes green, we can use that time as the time origin. But what if that data is not available, which is highly likely when working with low resolution live location data? 5.1 Find the Stage Telemetry Time Series Origin One approach would be to look to the timing and results data for data describing the start time of the stage for the particular data. This time can then be used as the tie origin (with a check to make sure it looks sensible!). But this approach brings with it the overhead of having to lookup that data via the WRC API. We can also set the time from a time passed as a string. For example: explicit_time_origin = ymd_hms(&quot;2020-04-01 10:30:13&quot;, tz=timezone) 5.1.1 Estimating the Start Time If we are missing timing data from the start of the run, and we assume that the run started exactly on the minute, we can round down the first sample time to get to the next nearest minute using the lubridate::round_date() function: first_time = route_telem_utm[1,]$utc first_time_rounded = round_date(first_time, unit=&quot;1 minutes&quot;) c(first_time, first_time_rounded) ## [1] &quot;2021-10-02 08:37:23 UTC&quot; &quot;2021-10-02 08:37:00 UTC&quot; We can then use the rounded first time as a basis for a running stage time estimate by subtracting that time from the sample datetimes: # Get stage time as a time object... route_telem_utm$roundeddelta_t = route_telem_utm$utc - first_time_rounded # And in seconds route_telem_utm$roundeddelta_s = as.double(route_telem_utm$roundeddelta_t) X accx accy altitude brk driverid gear heading kms name rpm speed status throttle track utx X_rally_stageid X_carentryid X_telemetryID X_name delta utc geometry dist roundeddelta_t roundeddelta_s 1870 0 0 0 0 NA 0 144 0.6 33 0 166 Competing 0 NA 1.633164e+12 bcc5537d-d28a-40af-ba86-95dad7fb9cd1 b185c5df-8115-40cf-bd81-566f016f6bf5 /a3f5f3f5-3fb0-42ab-af90-24d91c0493d0/ss07eva_telemetry_js/js Evans 0 2021-10-02 08:37:23 POINT (401052.2 6856758) 531.9830 23.6 secs 23.6 1869 0 0 0 0 NA 0 150 0.7 33 0 140 Competing 0 NA 1.633164e+12 bcc5537d-d28a-40af-ba86-95dad7fb9cd1 b185c5df-8115-40cf-bd81-566f016f6bf5 /a3f5f3f5-3fb0-42ab-af90-24d91c0493d0/ss07eva_telemetry_js/js Evans 3200 2021-10-02 08:37:26 POINT (401117.6 6856633) 673.7129 26.8 secs 26.8 1868 0 0 0 0 NA 0 172 0.8 33 0 60 Competing 0 NA 1.633164e+12 bcc5537d-d28a-40af-ba86-95dad7fb9cd1 b185c5df-8115-40cf-bd81-566f016f6bf5 /a3f5f3f5-3fb0-42ab-af90-24d91c0493d0/ss07eva_telemetry_js/js Evans 6400 2021-10-02 08:37:30 POINT (401142.7 6856572) 746.9263 30.0 secs 30.0 1867 0 0 0 0 NA 0 220 0.9 33 0 107 Competing 0 NA 1.633164e+12 bcc5537d-d28a-40af-ba86-95dad7fb9cd1 b185c5df-8115-40cf-bd81-566f016f6bf5 /a3f5f3f5-3fb0-42ab-af90-24d91c0493d0/ss07eva_telemetry_js/js Evans 9600 2021-10-02 08:37:33 POINT (401093 6856511) 825.5652 33.2 secs 33.2 1866 0 0 0 0 NA 0 210 1.0 33 0 149 Competing 0 NA 1.633164e+12 bcc5537d-d28a-40af-ba86-95dad7fb9cd1 b185c5df-8115-40cf-bd81-566f016f6bf5 /a3f5f3f5-3fb0-42ab-af90-24d91c0493d0/ss07eva_telemetry_js/js Evans 12800 2021-10-02 08:37:36 POINT (401020.1 6856413) 947.9104 36.4 secs 36.4 1865 0 0 0 0 NA 0 208 1.1 33 0 159 Competing 0 NA 1.633164e+12 bcc5537d-d28a-40af-ba86-95dad7fb9cd1 b185c5df-8115-40cf-bd81-566f016f6bf5 /a3f5f3f5-3fb0-42ab-af90-24d91c0493d0/ss07eva_telemetry_js/js Evans 16000 2021-10-02 08:37:39 POINT (400938.8 6856299) 1088.1680 39.6 secs 39.6 5.1.2 Using a False Origin Another approach to setting the origin is to not set one; or rather, to start the time series with a false origin, such as the first location point. The time into stage (from the false origin) can then be found by using the sample time of the first in-stage telemetry data point as the time origin set at that location. false_origin_time = route_telem_utm$utc[1] false_origin_time ## [1] &quot;2021-10-02 08:37:23 UTC&quot; And then generate deltas from that: # Get stage time as a time object... route_telem_utm$falsedelta_t = route_telem_utm$utc - false_origin_time # And in seconds route_telem_utm$falsedelta_s = as.double(route_telem_utm$falsedelta_t) kable(head(route_telem_utm %&gt;% select(c(utc, roundeddelta_t, roundeddelta_s, falsedelta_t, falsedelta_s))), format = &quot;html&quot;) %&gt;% kable_styling() %&gt;% kableExtra::scroll_box(width = &quot;100%&quot;) utc roundeddelta_t roundeddelta_s falsedelta_t falsedelta_s geometry 2021-10-02 08:37:23 23.6 secs 23.6 0.0 secs 0.0 POINT (401052.2 6856758) 2021-10-02 08:37:26 26.8 secs 26.8 3.2 secs 3.2 POINT (401117.6 6856633) 2021-10-02 08:37:30 30.0 secs 30.0 6.4 secs 6.4 POINT (401142.7 6856572) 2021-10-02 08:37:33 33.2 secs 33.2 9.6 secs 9.6 POINT (401093 6856511) 2021-10-02 08:37:36 36.4 secs 36.4 12.8 secs 12.8 POINT (401020.1 6856413) 2021-10-02 08:37:39 39.6 secs 39.6 16.0 secs 16.0 POINT (400938.8 6856299) This approach might also extended for use when comparing two or more drivers, by setting a false origin for each driver, then rebasing against a common origin set at the location origin furthest into the start for the drivers being compared. 5.2 Plotting the Stage Telemetry Time Series We can now plot the distance into stage and the stage time (as per the telemetry sample points) relative to each other. ggplot(route_telem_utm) +geom_line(aes(x=dist, y=roundeddelta_s)) If we have data for two or more cars, this would start to provide a basis for comparison. For example, we might be able to see the distance along the stage where their times diverge. We might also plot a distance versus time graph. "],["interpolating-times-along-the-route.html", "6 Interpolating Times Along the Route", " 6 Interpolating Times Along the Route Generating distances along the route, or “ghost” split points, gives us some basis for being able to make comparisons between cars. But we are still faced with a very particular problem: it’s unlikely that any two cars will generate telemetry sample points at the same location, which is to say, the same distance along the line. In order to compare times at the same location, as we do with official split times, we need to generate some sort of model that lets us interpolate times along the route. This would then allow us compare times, albeit estimated ones, at the same location. For more accuracy, this could should be done based on a speed model constructed from an analysis of route curvature. One way of doing this is to generate an estimator function based on the time and distance data in the telemetry data frame. # Estimate the time based on the distance into the route # Add in an origin time at the stage of the stage # If necessary, we could also add a crude acceleration effect # model at the start of the stage time_estimator = approxfun(c(0, route_telem_utm$dist), c(0, route_telem_utm$roundeddelta_s)) # Estimate the distance based on the time into the route distance_estimator = approxfun(route_telem_utm$roundeddelta_s, route_telem_utm$dist) We can then use these estimator functions to estimate times at particular distances along the route, and vice versa. For example, let’s create notional split points every 500 meters along the route, plotting both the predicted times and the actual times: # Sample every 500m vals = seq(to=max(route_telem_utm$dist), by=500) ggplot() + # Predicted line in pink geom_line(aes(x=vals, y=time_estimator(vals)), size=3, colour=&#39;pink&#39;) + # Sampled times in black geom_point(data=route_telem_utm, aes(x=dist, y=roundeddelta_s), color=&#39;black&#39;, size=1) If we have multiple drivers, we can generate an interpolation function for each one. These models can then be used to predict driver times at notional split point locations (for example, every 200 meters or so). In this way, we can try to identify where drivers are gaining or losing time with respect to each other and start to build up stage maps showing how drivers compare with each other along the whole length of the stage. "],["comparing-drivers-live-sparse-telemetry.html", "7 Comparing Drivers’ Live (Sparse) Telemetry 7.1 Load Route Data 7.2 Load Driver Data 7.3 Get Annotated Route Telemetry 7.4 Create Driver Estimators 7.5 Creating a Common False Time Origin 7.6 Visual Driver Comparison", " 7 Comparing Drivers’ Live (Sparse) Telemetry In this chapter, we will start to explore the extent we can compare the live telemetry data traces of different drivers. Note that te data may be quite sparse at times, which might limit what we are able to do. Where large gaps exist between data samples, we are more likely to require a sensible time model more the stage to try to minimise errors in using a simple, linear interpolator to generate missing data. 7.1 Load Route Data Get the route in a UTM form: geojson_filename = &quot;data/finland_2021.geojson&quot; geojson_sf = sf::st_read(geojson_filename) ## Reading layer `finland_2021&#39; from data source ## `/Users/tonyhirst/Documents/GitHub/visualising-wrc-telemetry-data/src/data/finland_2021.geojson&#39; ## using driver `GeoJSON&#39; ## Simple feature collection with 13 features and 2 fields ## Geometry type: GEOMETRY ## Dimension: XYZ ## Bounding box: xmin: 24.86575 ymin: 61.52393 xmax: 26.20794 ymax: 62.39946 ## z_range: zmin: 0 zmax: 148.839 ## Geodetic CRS: WGS 84 latlon_crs = 4326 # Use a convenience function that loads in the geojson file # and then generates a spatial features dataframe with a UTM projection stage_route_utm = get_route(geojson_sf, 7) ## Reading layer `finland_2021&#39; from data source ## `/Users/tonyhirst/Documents/GitHub/visualising-wrc-telemetry-data/src/data/finland_2021.geojson&#39; ## using driver `GeoJSON&#39; ## Simple feature collection with 13 features and 2 fields ## Geometry type: GEOMETRY ## Dimension: XYZ ## Bounding box: xmin: 24.86575 ymin: 61.52393 xmax: 26.20794 ymax: 62.39946 ## z_range: zmin: 0 zmax: 148.839 ## Geodetic CRS: WGS 84 stage_route_utm ## Simple feature collection with 1 feature and 2 fields ## Geometry type: LINESTRING ## Dimension: XY ## Bounding box: xmin: 400114.7 ymin: 6847317 xmax: 403275.1 ymax: 6857089 ## CRS: +proj=utm +zone=35 +datum=WGS84 +units=m +no_defs ## name styleUrl geometry ## 7 SS7/11 KakaristoHassi #msn_ylw-pushpin60 LINESTRING (400679.3 685708... We can obtain the stage length in meters from the route: # Get the stage length.. this includes the units stage_length_m = st_length(stage_route_utm) stage_length = drop_units(stage_length_m) stage_length ## [1] 18163.4 7.1.1 Generate Buffered Route We can also take this opportunity to create a buffered route for filtering the telemetry data: #Use a convenience function to get buffered route buffer_width = 50 buffered_route = get_buffered_route(stage_route_utm, buffer_width, crs=original_crs, utm=FALSE) leaflet(buffered_route) %&gt;% addProviderTiles(&quot;OpenTopoMap&quot;, group = &quot;OSM&quot;) %&gt;% addPolylines(color = &quot;red&quot;, weight = 2) 7.2 Load Driver Data Load in data for a handful of drivers: # Path to the telem data path = &quot;../../wrcplus/notebooks/2021_secto_Rally_Finland&quot; TO DO - set the origin as the dummy origin evans_min_telem = get_min_telem(&quot;Evans&quot;, &quot;SS7&quot;, path) evans_min_telem_utm = evans_min_telem %&gt;% st_transform(crs = st_crs(utm_proj4_string)) # Get the buffer filtered data route_telem_evans = get_route_telem(stage_route_utm, evans_min_telem_utm, crs=original_crs) evans_min_telem_utm ## Simple feature collection with 1871 features and 10 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: 386781.7 ymin: 6821405 xmax: 435552.1 ymax: 6901464 ## CRS: +proj=utm +zone=35 +datum=WGS84 +units=m +no_defs ## # A tibble: 1,871 × 11 ## X heading kms name speed status utx X_name ## * &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1870 144 0.6 33 166 Competing 1633163843600 Evans ## 2 1869 150 0.7 33 140 Competing 1633163846800 Evans ## 3 1868 172 0.8 33 60 Competing 1633163850000 Evans ## 4 1867 220 0.9 33 107 Competing 1633163853200 Evans ## 5 1866 210 1 33 149 Competing 1633163856400 Evans ## 6 1865 208 1.1 33 159 Competing 1633163859600 Evans ## 7 1864 194 1.3 33 149 Competing 1633163862800 Evans ## 8 1863 220 1.5 33 92 Competing 1633163869200 Evans ## 9 1862 176 1.6 33 117 Competing 1633163872400 Evans ## 10 1861 172 1.7 33 113 Competing 1633163875600 Evans ## # … with 1,861 more rows, and 3 more variables: geometry &lt;POINT [m]&gt;, ## # delta_s &lt;dbl&gt;, utc &lt;dttm&gt; We can always preview the data just to check that it is sensible: library(leaflet) tmp_route &lt;- evans_min_telem %&gt;% st_coordinates() leaflet(tmp_route) %&gt;% addProviderTiles(&quot;OpenTopoMap&quot;, group = &quot;OSM&quot;) %&gt;% addPolylines(color = &quot;purple&quot;, weight = 5) Let’s get some data for some other drivers: fourmaux_min_telem = get_min_telem(&quot;Fourmaux&quot;, &quot;SS7&quot;, path) fourmaux_min_telem_utm = fourmaux_min_telem %&gt;% st_transform(crs = st_crs(utm_proj4_string)) route_telem_fourmaux = get_route_telem(stage_route_utm, fourmaux_min_telem_utm, crs=original_crs) fourmaux_min_telem_utm ## Simple feature collection with 2971 features and 10 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: 386804.1 ymin: 6821404 xmax: 435545.6 ymax: 6901462 ## CRS: +proj=utm +zone=35 +datum=WGS84 +units=m +no_defs ## # A tibble: 2,971 × 11 ## X heading kms name speed status utx X_name ## * &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2970 328 28.1 16 62 Competing 1633163843700 Fourmaux ## 2 2969 328 28.2 16 61 Competing 1633163850100 Fourmaux ## 3 2968 328 28.3 16 55 Competing 1633163856500 Fourmaux ## 4 2967 310 29.4 16 75 Competing 1633163912000 Fourmaux ## 5 2966 240 29.5 16 79 Competing 1633163918400 Fourmaux ## 6 2965 232 29.6 16 80 Competing 1633163920500 Fourmaux ## 7 2964 296 29.7 16 78 Competing 1633163926900 Fourmaux ## 8 2963 280 29.8 16 83 Competing 1633163933300 Fourmaux ## 9 2962 312 30 16 70 Competing 1633163939700 Fourmaux ## 10 2961 284 30.1 16 81 Competing 1633163946100 Fourmaux ## # … with 2,961 more rows, and 3 more variables: geometry &lt;POINT [m]&gt;, ## # delta_s &lt;dbl&gt;, utc &lt;dttm&gt; breen_min_telem = get_min_telem(&quot;Breen&quot;, &quot;SS7&quot;, path) breen_min_telem_utm = breen_min_telem %&gt;% st_transform(crs = st_crs(utm_proj4_string)) route_telem_breen = get_route_telem(stage_route_utm, breen_min_telem_utm, crs=original_crs) route_telem_breen ## Simple feature collection with 84 features and 10 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: 25.10563 ymin: 61.7465 xmax: 25.15306 ymax: 61.83367 ## Geodetic CRS: WGS 84 ## # A tibble: 84 × 11 ## X heading kms name speed status utx X_name ## * &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2102 98 0.1 42 120 Competing 1633164186300 Breen ## 2 2101 102 0.2 42 77 Competing 1633164189500 Breen ## 3 2100 126 0.2 42 44 Competing 1633164192700 Breen ## 4 2099 136 0.3 42 101 Competing 1633164195900 Breen ## 5 2098 132 0.4 42 142 Competing 1633164199100 Breen ## 6 2097 138 0.5 42 167 Competing 1633164202300 Breen ## 7 2096 150 0.7 42 159 Competing 1633164205500 Breen ## 8 2095 154 0.8 42 73 Competing 1633164208700 Breen ## 9 2094 222 0.8 42 94 Competing 1633164211900 Breen ## 10 2093 212 1 42 139 Competing 1633164215100 Breen ## # … with 74 more rows, and 3 more variables: geometry &lt;POINT [°]&gt;, ## # delta_s &lt;dbl&gt;, utc &lt;dttm&gt; And preview the telemetry sample points for all the drivers we have gathered telemetry data for: leaflet( ) %&gt;% addProviderTiles(&quot;OpenTopoMap&quot;, group = &quot;OSM&quot;) %&gt;% addCircleMarkers(data=route_telem_evans, radius=1, color=&quot;blue&quot;) %&gt;% addCircleMarkers(data=route_telem_breen, radius=1,color=&quot;red&quot;) %&gt;% addCircleMarkers(data=route_telem_fourmaux, radius=1, color=&quot;black&quot;) 7.3 Get Annotated Route Telemetry The route telemetry annotation includes the distance along the stage route for each telemetry sample: route_telem_evans_utm = to_utm(route_telem_evans) route_telem_evans_utm = route_telem_evans_utm %&gt;% get_telem_dists(stage_route_utm) #route_telem_evans_utm route_telem_fourmaux_utm = to_utm(route_telem_fourmaux) route_telem_fourmaux_utm = route_telem_fourmaux_utm %&gt;% get_telem_dists(stage_route_utm) route_telem_fourmaux_utm ## Simple feature collection with 57 features and 13 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: 400112.8 ymin: 6848161 xmax: 403238.1 ymax: 6857092 ## CRS: +proj=utm +zone=35 +datum=WGS84 +units=m +no_defs ## # A tibble: 57 × 14 ## X heading kms name speed status utx X_name ## * &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 217 100 0 16 106 Competing 1633187766200 Fourmaux ## 2 216 112 0.1 16 90 Competing 1633187769400 Fourmaux ## 3 215 144 0.3 16 85 Competing 1633187775800 Fourmaux ## 4 214 132 0.4 16 134 Competing 1633187779000 Fourmaux ## 5 213 136 0.5 16 160 Competing 1633187782200 Fourmaux ## 6 212 148 0.8 16 83 Competing 1633187788600 Fourmaux ## 7 211 212 1 16 153 Competing 1633187798200 Fourmaux ## 8 210 206 1.3 16 130 Competing 1633187804600 Fourmaux ## 9 209 244 1.4 16 141 Competing 1633187807800 Fourmaux ## 10 208 204 1.5 16 86 Competing 1633187811000 Fourmaux ## # … with 47 more rows, and 6 more variables: geometry &lt;POINT [m]&gt;, ## # delta_s &lt;dbl&gt;, utc &lt;dttm&gt;, dist &lt;dbl&gt;, roundeddelta_t &lt;drtn&gt;, ## # roundeddelta_s &lt;dbl&gt; 7.4 Create Driver Estimators From the annotated data can generate some naive estimators for stage time along route based on distance along route: fourmaux_time_estimator = approxfun(c(0, route_telem_fourmaux_utm$dist), c(0, route_telem_fourmaux_utm$roundeddelta_s)) ## Warning in regularize.values(x, y, ties, missing(ties), na.rm = na.rm): ## collapsing to unique &#39;x&#39; values evans_time_estimator = approxfun(c(0, route_telem_evans_utm$dist), c(0, route_telem_evans_utm$roundeddelta_s)) 7.5 Creating a Common False Time Origin TO DO 7.6 Visual Driver Comparison Let’s see if a visual comparison reveals anything: # Sample every 500m vals = seq(to=max(c(route_telem_fourmaux_utm$dist, route_telem_evans_utm$dist)), by=500) ggplot() + # Predicted line in pink geom_line(aes(x=vals, y=evans_time_estimator(vals)), size=1, colour=&#39;blue&#39;) + geom_point(data=route_telem_evans_utm, aes(x=dist, y=roundeddelta_s), size=1, colour=&#39;red&#39;) + # Sampled times in black geom_line(aes(x=vals, y=fourmaux_time_estimator(vals)), color=&#39;red&#39;, size=1) + geom_point(data=route_telem_fourmaux_utm, aes(x=dist, y=roundeddelta_s), size=1, colour=&#39;blue&#39;) "],["finding-the-time-to-complete-a-particular-stretch.html", "8 Finding the Time to Complete a Particular Stretch", " 8 Finding the Time to Complete a Particular Stretch In order to compare the time it takes two or more drivers to cover the same stretch of a stage route, we need to find out how long it takes each of them to cover that distance. The following function will chunk the route into fixed length segments (exempt the final segment) and find out how long it takes the driver to complete that section. # Return time to travel along a segment. # Units relate to whether the distances are in eg m or km segmentTimeDelta = function(driver_estimator, cumdist, stretch=100, units=&#39;m&#39;){ driver_estimator(cumdist+stretch) - driver_estimator(cumdist) } We can now generate a simple estimate of the time taken to complete each segment: #18163.4 %/% 1000 -&gt; 18 # Get sections 1000m long segment_length = 1000 #units = &#39;m&#39; #segment_length_m = set_units(segment_length, m) segments = seq(from=0, to=stage_length, by = segment_length) evans_1km_segments = segmentTimeDelta(evans_time_estimator, segments, segment_length) evans_1km_segments ## [1] 37.58843 26.93338 28.29342 26.21198 30.94418 24.63189 27.20249 31.85834 ## [9] 32.99157 25.37383 36.76296 27.10636 28.68083 20.69407 20.13347 31.38227 ## [17] 26.35240 NA NA Let’s also grab similar estimates for another driver: fourmaux_1km_segments = segmentTimeDelta(fourmaux_time_estimator, segments, segment_length) fourmaux_1km_segments ## [1] 35.36710 28.22918 28.49147 27.66114 31.34492 26.23118 29.05474 32.60108 ## [9] 34.48317 31.58292 32.36769 27.78844 27.56022 25.43212 25.43212 25.43212 ## [17] 25.43212 25.43212 NA "],["estimating-time-deltas-between-drivers-over-small-sections.html", "9 Estimating Time Deltas Between Drivers Over Small Sections", " 9 Estimating Time Deltas Between Drivers Over Small Sections We can now generate a list of delta values describing the time difference between the drivers in completing each section. Note that if the telemetry samples are widely separated, this estimates might be quite poor, particularly if they are based on linear interpolation of times between points. dummy_split_deltas = evans_1km_segments - fourmaux_1km_segments head(dummy_split_deltas, 3) ## [1] 2.2213305 -1.2957991 -0.1980497 If we cast the original route to a trajr directory, we can easily split the route into separate sections based on the cumulative distance of steps along the route. library(trajr) trj &lt;- TrajFromCoords(as.data.frame(st_coordinates(stage_route_utm))) trj$distance = Mod(trj$displacement) # Note that the trj object natively also provides a displacement time trj$cum_dist = cumsum(trj$distance) We can then plot the route with the time delta highlighted: g = ggplot()+ coord_fixed() # Create a trace for each segment for (i in 1:length(segments)){ start=(i-1)*segment_length end= start+segment_length # Filter out the part of the trajectory we want to plot segment_filter = trj$cum_dist &gt;= start &amp; trj$cum_dist &lt;= end route_segment = trj[segment_filter,] # Set colour based on delta c= dummy_split_deltas[i] if (is.na(c)) c=0 route_segment$c = c # Add segment to plot g = g+geom_path(data=route_segment, aes(x=x, y=y, color=c)) } # Render plot g+scale_colour_gradient( low = &quot;red&quot;, high = &quot;green&quot;, breaks=c(0)) # TO DO TO DO - can we split on the route using split points a distance along the route? # not required? getlocation = function(route_utm, dist, units=&#39;m&#39;) { sample_point_sp_utm = rgeos::gInterpolate(as(route_utm, &quot;Spatial&quot;), dist, # Distance along route in meters normalized = FALSE) # We can convert back from an sp to an sf object: sample_point_sf_utm = st_as_sf(sample_point_sp_utm) # And also convert back to a latlong reference system sample_point_sf = sample_point_sf_utm %&gt;% st_transform(crs = st_crs(latlon_crs)) sample_point_sf } getlocation(stage_route_utm, c(1500, 2000)) ## Warning in proj4string(spgeom): CRS object has comment, which is lost in output ## Simple feature collection with 2 features and 0 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: 25.11525 ymin: 61.81992 xmax: 25.11939 ymax: 61.82377 ## Geodetic CRS: WGS 84 ## geometry ## 1 POINT (25.11525 61.82377) ## 2 POINT (25.11939 61.81992) # Not required? df_dummy_split_points = getlocation(stage_route_utm, segments) df_dummy_split_coords = df_dummy_split_points %&gt;% st_coordinates() %&gt;% as.data.frame() %&gt;% rename(lon=X, lat=Y) df_dummy_split_coords$delta = dummy_split_deltas head(df_dummy_split_coords, 3) ## lon lat delta ## 1 25.11383 61.83364 2.2213305 ## 2 25.12013 61.82727 -1.2957991 ## 3 25.11939 61.81992 -0.1980497 We can also split the co-ordinates out from the geometry using a recipe such as: #https://stackoverflow.com/questions/54734771/sf-write-lat-long-from-geometry-into-separate-column-and-keep-id-column #df %&gt;% # mutate(lat = unlist(map(geometry,1)), # long = unlist(map(geometry,2))) "],["interpolation-using-a-route-speed-model.html", "10 Interpolation Using A Route Speed Model 10.1 Creating a Route Speed Model", " 10 Interpolation Using A Route Speed Model Based on the curvature of the route, the speed model gives us a crude estimate of how long it takes to get between two points. If the route is a flat straight between the points, we’ll travel 1km in much less time than if the route it tight and twisty. The simple approxfun() interpolator uses a linear model to interpolate times between actual time points, but we might be able to improve interpolated estimates using a non-linear model based on a speed model generated over the route based on the route curvature. identify distance into stage required (desired_d) find distance into stage for each get consecutive telemetry points between which desired distance lays (in_d, out_d, in_t, out_t) &gt; l = c(1.1,2.1,3.1,4.1,5.1) &gt; c(l[findInterval(3, l)], l[findInterval(3, l)+1]) [1] 2.1 3.1 &gt; c(l[findInterval(1, l)], l[findInterval(1, l)+1]) [1] 1.1 &gt; c(l[findInterval(11, l)], l[findInterval(11, l)+1]) [1] 5.1 NA get speed model get model time at points (in_mt=model(in_d), out_mt=model(out_d), desired_mt=model(desired_d)) get interpolated normalised model time between points, desired_nt = (desired_mt - in_mt)/(out_mt - in_mt) get predicted time desired_t = desired_nt*(out_t - in_t) + in_t 10.1 Creating a Route Speed Model In the To See The Invisible rally pacenotes tutorial series by David Nafría, corners are given a particular severity based on curvature. Simple models of expected speeds for corners of a particular severity are also described for different classes of rally car. We can use this approach to create a simple speed model based on curvature of the rally route. Using the expected cornering speed as a target speed and a simple acceleration model, as well as theoretical maximum speed, we can accelerate the car into and out of each corner based and generate a speed model as a result. For more on analysing and visualising rally stage routes, see Visualising WRC Rally Stages With rayshader and R. The rLFT processing linear features R package provides a handy tool for modeling curvature along each point of a route in the form of a boundary convexity tool (bct()). The curvature of a moving segment along the route is determined, along with the center of curvature and a convexity measure. library(rLFT) # The step dist is how far we move the window at each step stepdist = 10 # The window is the length of the route for which we find the curvature window = 20 get_route_convexity = function(route_basis_utm, stepdist=10, window=20){ bct(route_basis_utm, # distance between measurements step = stepdist, window = window, ridName = &quot;name&quot;) %&gt;% mutate(dist = (lead(MidMeas)-MidMeas), cum_dist = cumsum(dist)) } route_convexity = get_route_convexity(stage_route_utm) ## user system elapsed ## 0.181 0.031 0.213 ## [1] &quot;Features skipped due to size: &quot; ## logical(0) head(route_convexity, 3) ## FID RID MidMeas WindowSize RawConvexity ConvexityIndex ## 1 1 SS7/11 KakaristoHassi 10 20 0.000 0.000 ## 2 1 SS7/11 KakaristoHassi 20 20 0.000 0.000 ## 3 1 SS7/11 KakaristoHassi 30 20 0.788 0.079 ## Sinuosity Midpoint_X Midpoint_Y dist cum_dist ## 1 0.500 400689.0 6857086 10 10 ## 2 0.500 400698.6 6857084 10 20 ## 3 0.503 400708.3 6857081 10 30 Although the boundary convexity tool gives us a convexity measure, we can also create our own curvature metric that corresponds more closely to Nafría’s model. I don’t know how to write vectorised functions properly, so I’ll create a simple function that generates the curvature at a particular point on a route, and then use the Vectorize() helper function to as-if vectorise it for me. library(devtools) # The curvature function takes an arc defined over # x and y coordinate lists #circlefit, from pracma:: circlefit = function (xp, yp, fast = TRUE) { if (!is.vector(xp, mode = &quot;numeric&quot;) || !is.vector(yp, mode = &quot;numeric&quot;)) stop(&quot;Arguments &#39;xp&#39; and &#39;yp&#39; must be numeric vectors.&quot;) if (length(xp) != length(yp)) stop(&quot;Vectors &#39;xp&#39; and &#39;yp&#39; must be of the same length.&quot;) if (!fast) warning(&quot;Option &#39;fast&#39; is deprecated and will not be used!&quot;, call. = FALSE, immediate. = TRUE) n &lt;- length(xp) p &lt;- qr.solve(cbind(xp, yp, 1), matrix(xp^2 + yp^2, ncol = 1)) v &lt;- c(p[1]/2, p[2]/2, sqrt((p[1]^2 + p[2]^2)/4 + p[3])) rms &lt;- sqrt(sum((sqrt((xp - v[1])^2 + (yp - v[2])^2) - v[3])^2)/n) #cat(&quot;RMS error:&quot;, rms, &quot;\\n&quot;) return(v) } curvature = function(x,y){ #729181.8, 729186.1, 729190.4 #4957667 , 4957676, 4957685 tryCatch({ # circlefit gives an error if we pass a straight line # Also hide the print statement in circlefit # circlefit() returns the x and y coords of the circle center # as well as the radius of curvature # We could then also calculate the angle and arc length circlefit(x,y)[3] }, error = function(err) { # For a straight, return the first co-ord and Inf diameter # Alternatively, pass zero diameter? c(x[1], y[1], Inf)[3]}) } curvature2 = function(x1, x2, x3, y1, y2, y3){ curvature(c(x1, x2, x3), c(y1, y2, y3)) } # The base::Vectorize function provides a lazy way of # vectorising a non-vectorised function curvatures_ = Vectorize(curvature2) curvatures = function(route_convexity){ curvatures_(lag(route_convexity$Midpoint_X), route_convexity$Midpoint_X, lead(route_convexity$Midpoint_X), lag(route_convexity$Midpoint_Y), route_convexity$Midpoint_Y, lead(route_convexity$Midpoint_Y)) } This model uses the corner centre measures calculated by the boundary convexity tool to return a radius for the curvature of each segment: route_convexity$radius = curvatures(route_convexity) We can now generate the cornering speed model. The corner speed model generates several things: a corner index, invisble_ci, which is an integer representing the corner radius; a notional segment/corner target speed, invisible_sp. corner_speed_model = function(route_convexity, invisible_speeds = c(20, 40, 50, 60, 70, 85, 100, 115, 120, 130, 170)){ invisible_bins = c(0, 10, 15, 20, 27.5, 35, 45, 60, 77.5, 100, 175, Inf) route_convexity$invisible_ci = cut(route_convexity$radius, breaks = invisible_bins, labels = 1:(length(invisible_bins)-1), ordered_result=TRUE) # Speeds in km/h #invisible_speeds = c(10, 40, 50, 60, 70, 80, # 95, 110, 120, 130, 180) route_convexity$invisible_sp = cut(route_convexity$radius, breaks = invisible_bins, labels = invisible_speeds, ordered_result=TRUE) # Cast speed as factor, via character, to integer route_convexity$invisible_sp = as.integer(as.character(route_convexity$invisible_sp)) route_convexity } Applying the speed model to our route gives us a corner index and notional target speed for each segment: route_convexity = route_convexity %&gt;% corner_speed_model() head(route_convexity, 3) ## FID RID MidMeas WindowSize RawConvexity ConvexityIndex ## 1 1 SS7/11 KakaristoHassi 10 20 0.000 0.000 ## 2 1 SS7/11 KakaristoHassi 20 20 0.000 0.000 ## 3 1 SS7/11 KakaristoHassi 30 20 0.788 0.079 ## Sinuosity Midpoint_X Midpoint_Y dist cum_dist radius invisible_ci ## 1 0.500 400689.0 6857086 10 10 Inf 11 ## 2 0.500 400698.6 6857084 10 20 Inf 11 ## 3 0.503 400708.3 6857081 10 30 Inf 11 ## invisible_sp ## 1 170 ## 2 170 ## 3 170 We can build up the speed model for the route. At each step we accelerate towards the nominal sector target speed (the invisible_sp value). We can’t accelerate infinitely fast, so our actual target accumulated speed for the segment, acc_sp, is a simple function of the current speed and the notional target speed. We can then calculate the notional time to complete that segment, invisible_time. acceleration_model = function(route_convexity, stepdist=10, acc = 0.1, dec = 0.1) { # Acceleration model sp = route_convexity$invisible_sp # Nominal starting target speed # In we don&#39;t set this, we don&#39;t get started moving sp[1] = 30 # Use crude acceleration / brake weights for (i in 2:(length(sp)-1)) { # Simple linear model - accumulated speed is based on # the current speed and the notional segment speed # Accelerate up if (sp[i-1]&lt;=sp[i]) sp[i] = (sp[i-1] + acc * sp[i]) / (1+acc) # Decelerate down if (sp[i]&gt;sp[i+1]) sp[i] = (dec * sp[i] + sp[i+1]) / (1+dec) } route_convexity$acc_sp = sp route_convexity$acc_sp[length(sp)] = route_convexity$invisible_sp[length(sp)] # New time model # Also get speed in m/s for time calculation meters = 1000 seconds_per_hour = 3600 # 60 * 60 kph_unit = meters / seconds_per_hour route_convexity = route_convexity %&gt;% mutate(segment_sp = route_convexity$acc_sp * kph_unit, invisible_time = dist/segment_sp, acc_time = cumsum(invisible_time)) # So now we need to generate kilometer marks route_convexity$kmsection = 1 + trunc(route_convexity$MidMeas/1000) # We can use this to help find the time over each km route_convexity } If we now apply the acceleration model to the route, we can calculate the speed over each segment, and the time taken to complete the segment: route_convexity = acceleration_model(route_convexity) head(route_convexity, 3) ## FID RID MidMeas WindowSize RawConvexity ConvexityIndex ## 1 1 SS7/11 KakaristoHassi 10 20 0.000 0.000 ## 2 1 SS7/11 KakaristoHassi 20 20 0.000 0.000 ## 3 1 SS7/11 KakaristoHassi 30 20 0.788 0.079 ## Sinuosity Midpoint_X Midpoint_Y dist cum_dist radius invisible_ci ## 1 0.500 400689.0 6857086 10 10 Inf 11 ## 2 0.500 400698.6 6857084 10 20 Inf 11 ## 3 0.503 400708.3 6857081 10 30 Inf 11 ## invisible_sp acc_sp segment_sp invisible_time acc_time kmsection ## 1 170 30.00000 8.333333 1.2000000 1.200000 1 ## 2 170 42.72727 11.868687 0.8425532 2.042553 1 ## 3 170 54.29752 15.082645 0.6630137 2.705567 1 Summing over the segment times (omitting the flying finish which has no specified ongoing segment length) gives us an estimated stage time anticipated_time = function(route_convexity) { anticipated_time = sum(route_convexity$invisible_time[1:nrow(route_convexity)-1]) cat(paste0(&quot;Anticipated stage time: &quot;, anticipated_time %/% 60, &#39;m &#39;, round(anticipated_time %% 60, 1), &#39;s&#39; )) } anticipated_time(route_convexity) ## Anticipated stage time: 9m 11.2s We can also view the speed model over distance into stage: ggplot(route_convexity) + geom_line(aes(x=cum_dist, y=acc_sp)) We can also plot the time model into the stage as the accumulated time: ggplot(route_convexity) + geom_line(aes(x=cum_dist, y=acc_time)) "],["full-telemetry.html", "11 Full telemetry", " 11 Full telemetry As well as the sparse, low frequency telemetry that we can capture from the live data service whilst a stage is running, more substantial telemetry datasets are published several hours after a stage has run when the WRC onboard video views are made available. The density of points is high enough to allow us to make a reasonable estimate on how far a car is into to the stage based simply on summing the distances between consecutive sample locations. However, this does mean that the distance metric is dependent on the actual route taken by a driver. Whilst drivers will typically take a similar line, a more exact comparison based on distance into the stage can be generated by mapping each sample location on the nearest location on the official route. Inspection of the telemetry files suggests that the data is presented in a common form, with actual clock start represented by a negative time stamp injected into the second row of the dataframe. (The first and third rows are perhaps actual telemetry data.) Load in the full resolution telemetry: get_full_telem = function (fp, proj=utm_proj4_string, utm=FALSE){ # TO DO - the proj parameter is not used? telem_df_full_raw = read.csv(fp) %&gt;% drop_na(&quot;lon&quot;, &quot;lat&quot;) %&gt;% map_df(rev) %&gt;% # Omit the negative start time in row 2 filter(utx &gt; 0) %&gt;% mutate(utc = as_datetime(utx/1000)) # We could further tune the locations to be projections onto the route # This would then ensure a normalisation of the distance into the stage # against a common origin # TO DO - here we explicitly set the lat long crs # TO DO - don&#39;t use the literal 4326 telem_df_full_raw$lonX = telem_df_full_raw$lon telem_df_full_raw$latX = telem_df_full_raw$lat telem_df_full = telem_df_full_raw %&gt;% st_as_sf(coords = c(&quot;lonX&quot;,&quot;latX&quot;)) %&gt;% st_set_crs(4326) # Inject name from file name into dataframe # Remove accents clean_fp = stringi::stri_trans_general(fp, &quot;Latin-ASCII&quot;) metadata = str_match(fp, &quot;.*df_telemetrymergeddata_(SS.*)_(.*).csv&quot;) stage_ = metadata[2] driver_ = str_trim(stringi::stri_trans_general(metadata[3], &quot;Latin-ASCII&quot;)) telem_df_full$driver = driver_ telem_df_full$stage = stage_ # If required, we can get a UTM projection at this point if (utm) { telem_df_full_utm = st_transform(telem_df_full, crs = st_crs(utm_proj4_string)) telem_df_full_utm } else { telem_df_full } } We can then load the telemetry data in fn=&quot;df_telemetrymergeddata_SS7_Evans.csv&quot; telem_df_full = get_full_telem(file.path(path, fn)) How many data points? nrow(telem_df_full %&gt;% st_coordinates() ) ## [1] 4377 As we can see, the full telemetry gives us quite closely sampled points along the route: leaflet(telem_df_full) %&gt;% addProviderTiles(&quot;OpenTopoMap&quot;, group = &quot;OSM&quot;) %&gt;% addCircleMarkers(weight = 1) Or how about plotting the data using ggplot: ggplot(data=telem_df_full) + geom_sf(aes(color=speed), size=0.1) "],["generating-a-trajr-route-from-the-telemetry-data.html", "12 Generating a trajr Route From the Telemetry Data", " 12 Generating a trajr Route From the Telemetry Data With a large number of points available, we can cast the dataset directly to a trajr route. The trajr R package was originally developed for use analysing animal tracks, but it’s also really handy for analysing rally routes… telemetry_full_trajectory = function(telem_df_full){ utm_telem_full = st_transform(telem_df_full, crs=utm_proj4_string) %&gt;% mutate(lat = st_coordinates(.)[,1], lon = st_coordinates(.)[,2]) trj &lt;- TrajFromCoords(utm_telem_full %&gt;% select(lon, lat, utc), xCol=&quot;lon&quot;, yCol=&quot;lat&quot;, timeCol=&quot;utc&quot;) # We assume that the first location is the first location on the route trj$distance = Mod(trj$displacement) trj$cum_dist = cumsum(trj$distance) trj$speed = telem_df_full$speed trj$brk = telem_df_full$brk trj$throttle = telem_df_full$throttle trj$rpm = telem_df_full$rpm trj$lon = telem_df_full$lon trj$lat = telem_df_full$lat trj$accx = telem_df_full$accx trj$accy = telem_df_full$accy trj$driver = telem_df_full$driver trj$stage = telem_df_full$stage trj } The data includes: lat/lon coordinates; a sample timestamp; speed in km/h; throttle and brk (brake) as percentage values; rpm revs; accx and accy acceleration forces. If we plot these values against the distance into stage, generated from the location data and cross-referenced to the nearest point on the official stage route, we can generate an idealised basis for comparison between different drivers. However, given that drivers typically follow a very similar line, and hence complete a similar distance over the stage, using their actual distance into the route should provide a reasonable, if approximate, basis for comparison most of the time. The trajr route actually calculates a distance into the route assuming an origin based on the first point in the route. evans_fn=&quot;df_telemetrymergeddata_SS7_Evans.csv&quot; trj_evans = telemetry_full_trajectory(get_full_telem(file.path(path, evans_fn))) ogier_fn=&quot;df_telemetrymergeddata_SS7_Ogier.csv&quot; trj_ogier = telemetry_full_trajectory(get_full_telem(file.path(path, ogier_fn))) breen_fn=&quot;df_telemetrymergeddata_SS7_Breen.csv&quot; trj_breen = telemetry_full_trajectory(get_full_telem(file.path(path, breen_fn))) "],["finding-distance-into-a-common-route.html", "13 Finding Distance into a Common Route", " 13 Finding Distance into a Common Route To provide for an exact comparison of times based on distance into stage, we can map distances onto the “official” route. However, if the official route does not match the actual route, we may get a “false” distance measures. For example, if the “official” route starts some way along the actual route as recorded in telemetry, then we will lose information at the start of the route. Another approach might be to generate out own unofficial official route by creating a small buffer around the intersection of the captured route telemetry and then looking up roads using OSM within that buffered area; such a road should be unique (assuming that the stage route follows tracks that appear on OpenStreetMap) and could then be used as the official route. dist_into_route = function(trj_utm, stage_route_utm) { # telem_df_full_utm = st_transform(telem_df_full, # crs = st_crs(utm_proj4_string)) full_pois_utm = st_sfc(st_multipoint(st_coordinates(trj_utm)), crs=st_crs(trj_utm)) full_pois_points_utm = st_cast(x = full_pois_utm, to = &quot;POINT&quot;) full_pois_points_utm_sp = as(full_pois_points_utm, &#39;Spatial&#39;) # Find the distance along the route of the point on the route # nearest to each telemetry sample rgeos::gProject(as(stage_route_utm,&quot;Spatial&quot;), full_pois_points_utm_sp, normalized = FALSE) } We can now get the distance into route for each telemetry point: # This throws a warning? trj_evans$dist_into_route = dist_into_route(trj_evans, stage_route_utm) trj_ogier$dist_into_route = dist_into_route(trj_ogier, stage_route_utm) Another approach would be simple to project one driver’s route onto the route taken by a driver we are comparing them against and then finding times based distance into this common route projection. "],["looking-at-braking-behaviour.html", "14 Looking At Braking Behaviour 14.1 Throttle Comparison", " 14 Looking At Braking Behaviour Where do we brake? #library(ggspatial) # annotation_spatial(trj_ogier ) + # layer_spatial(trj_ogier, aes(alpha = brk), color=&#39;red&#39;,size=0.3) #https://github.com/eliocamp/ggnewscale # Multiple color scales # ?doesn&#39;t work with geom_sf which overplots? library(ggnewscale) ggplot() + stat_sf_coordinates(aes( color=throttle),size=0.1, geom = &quot;point&quot;, data=trj_ogier %&gt;% filter(throttle&gt;0)) + scale_color_gradient(low = &quot;white&quot;, high = &quot;green&quot;) + new_scale_color() + scale_color_gradient(low = &quot;white&quot;, high = &quot;red&quot;)+ stat_sf_coordinates( aes( color=brk), size=0.1, geom = &quot;point&quot;, data=trj_ogier %&gt;% filter(brk&gt;0) ) + # How do we get the correct projection #_coord_map() # Already rectilinear... coord_fixed() 14.1 Throttle Comparison How do our two drivers compare in their use of the throttle? ggplot() + geom_line(data=(trj_ogier %&gt;% filter(cum_dist&gt;=1000 &amp; cum_dist&lt;=2000)), aes(x=cum_dist,y=throttle), color=&#39;red&#39;) + geom_line(data=(trj_evans %&gt;% filter(cum_dist&gt;=1000 &amp; cum_dist&lt;=2000)), aes(x=cum_dist,y=throttle), color=&#39;blue&#39;) With smoothing: library(zoo) ## ## Attaching package: &#39;zoo&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.Date, as.Date.numeric ggplot() + geom_line(data=trj_ogier%&gt;% filter(cum_dist&gt;=1000 &amp; cum_dist&lt;=2000) %&gt;% mutate(smooth_throttle=rollmean(throttle, k = 3, fill = NA)), aes(x=cum_dist,y=smooth_throttle), color=&#39;red&#39;) + geom_line(data=(trj_evans %&gt;% filter(cum_dist&gt;=1000 &amp; cum_dist&lt;=2000) %&gt;% mutate(smooth_throttle=rollmean(throttle, k = 3, fill = NA))), aes(x=cum_dist,y=smooth_throttle), color=&#39;blue&#39;) ## Warning: Removed 2 row(s) containing missing values (geom_path). ## Warning: Removed 2 row(s) containing missing values (geom_path). We can also explore adding throttle and brake data to the speed trace. theme_black = function(base_size = 12, base_family = &quot;&quot;) { theme_grey(base_size = base_size, base_family = base_family) %+replace% theme( # Specify axis options axis.line = element_blank(), axis.text.x = element_text(size = base_size*0.8, color = &quot;white&quot;, lineheight = 0.9), axis.text.y = element_text(size = base_size*0.8, color = &quot;white&quot;, lineheight = 0.9), axis.ticks = element_line(color = &quot;white&quot;, size = 0.2), axis.title.x = element_text(size = base_size, color = &quot;white&quot;, margin = margin(0, 10, 0, 0)), axis.title.y = element_text(size = base_size, color = &quot;white&quot;, angle = 90, margin = margin(0, 10, 0, 0)), axis.ticks.length = unit(0.3, &quot;lines&quot;), # Specify legend options legend.background = element_rect(color = NA, fill = &quot;black&quot;), legend.key = element_rect(color = &quot;white&quot;, fill = &quot;black&quot;), legend.key.size = unit(1.2, &quot;lines&quot;), legend.key.height = NULL, legend.key.width = NULL, legend.text = element_text(size = base_size*0.8, color = &quot;white&quot;), legend.title = element_text(size = base_size*0.8, face = &quot;bold&quot;, hjust = 0, color = &quot;white&quot;), legend.position = &quot;right&quot;, legend.text.align = NULL, legend.title.align = NULL, legend.direction = &quot;vertical&quot;, legend.box = NULL, # Specify panel options panel.background = element_rect(fill = &quot;black&quot;, color = NA), panel.border = element_rect(fill = NA, color = &quot;white&quot;), panel.grid.major = element_line(color = &quot;grey35&quot;), panel.grid.minor = element_line(color = &quot;grey20&quot;), panel.margin = unit(0.5, &quot;lines&quot;), # Specify faceting options strip.background = element_rect(fill = &quot;grey30&quot;, color = &quot;grey10&quot;), strip.text.x = element_text(size = base_size*0.8, color = &quot;white&quot;), strip.text.y = element_text(size = base_size*0.8, color = &quot;white&quot;,angle = -90), # Specify plot options plot.background = element_rect(color = &quot;black&quot;, fill = &quot;black&quot;), plot.title = element_text(size = base_size*1.2, color = &quot;white&quot;), plot.margin = unit(rep(1, 4), &quot;lines&quot;) ) } What happens if we try to colour the speed line according to the throttle and brake percentages? ggplot() + #geom_line(data=trj_ogier %&gt;% filter(cum_dist&gt;=1000 &amp; cum_dist&lt;=2000), # aes(x=cum_dist,y=speed), color=&#39;white&#39;, size=4) + geom_line(data=trj_ogier %&gt;% filter(cum_dist&gt;=1000 &amp; cum_dist&lt;=2000), aes(x=cum_dist,y=speed, alpha=throttle), size=1, color=&quot;green&quot;) + geom_line(data=trj_ogier %&gt;% filter(cum_dist&gt;=1000 &amp; cum_dist&lt;=2000), aes(x=cum_dist,y=speed-3, alpha=brk), color=&quot;red&quot;, size=1) + geom_line(data=trj_ogier %&gt;% filter(cum_dist&gt;=1000 &amp; cum_dist&lt;=2000), aes(x=cum_dist,y=throttle-50, alpha=100-brk), size=1, color=&quot;green&quot;) + geom_line(data=trj_ogier %&gt;% filter(cum_dist&gt;=1000 &amp; cum_dist&lt;=2000), aes(x=cum_dist,y=brk-50, alpha=100-throttle), color=&quot;red&quot;, size=1)+ theme_black()+ theme(legend.position=&quot;none&quot;) ## Warning: `panel.margin` is deprecated. Please use `panel.spacing` property ## instead ggplot(data=telem_df_full) + geom_sf(aes(color=throttle), size=0.1) ggplot(data=telem_df_full) + geom_sf(aes(color=-brk), size=0.1) "],["comparing-times-into-stage.html", "15 Comparing Times Into Stage", " 15 Comparing Times Into Stage How do our drivers compare based on the time it takes them to driver a particular distance into the stage? Recall that we are using each car’s own accumulated distance in to stage measure, rather than comparing times at distances into stage measured along some common, idealised route. Sample common points to find the difference: segment_length=100 # stage_length set in earlier section segments = seq(from=0, to=stage_length, by = segment_length) ogier_full_estimator = approxfun(trj_ogier$cum_dist, trj_ogier$displacementTime) ## Warning in regularize.values(x, y, ties, missing(ties), na.rm = na.rm): ## collapsing to unique &#39;x&#39; values evans_full_estimator = approxfun(trj_evans$cum_dist, trj_evans$displacementTime) ## Warning in regularize.values(x, y, ties, missing(ties), na.rm = na.rm): ## collapsing to unique &#39;x&#39; values ogier_time_points = ogier_full_estimator(segments) evans_time_points = evans_full_estimator(segments) ogier_evans_point_delta = ogier_time_points - evans_time_points # Difference in time take to reach a particular point in the stage ggplot()+geom_line(aes(x=segments, y=ogier_evans_point_delta)) Compare time into stage for a given distance into stage. Note that this is the distance into the stage as calculated from the trajectory, rather than by comparison of distances into the same (idealised) route. ggplot() + geom_line(data=(trj_ogier %&gt;% mutate(dt=as.double(displacementTime)) %&gt;% filter(dt &gt;=0)), aes(x=cum_dist,y=dt), color=&#39;blue&#39;) + geom_line(data=(trj_evans %&gt;% mutate(dt=as.double(displacementTime)) %&gt;% filter(dt &gt;=0)), aes(x=cum_dist,y=dt), color=&#39;grey&#39;) "],["correlating-telemetry-traces.html", "16 Correlating Telemetry Traces", " 16 Correlating Telemetry Traces We can use a cross-correlation function to try to identify the extent to which traces are similar across drivers. The approxfun() estimator does a very simple interpoloation between consecutive values in the original dataset, which means that actual telemetry data values are pinned in the prediction model and used for local estimation. ts_estimator = function(df, x, y, points){ estimator_ = approxfun(df[[x]], df[[y]]) estimator_(points) } We can use this function to estimate different properties from the time series telemetry data. ogier_speed_est = ts_estimator(trj_ogier, &quot;cum_dist&quot;, &quot;speed&quot;, segments) ## Warning in regularize.values(x, y, ties, missing(ties), na.rm = na.rm): ## collapsing to unique &#39;x&#39; values evans_speed_est = ts_estimator(trj_evans, &quot;cum_dist&quot;, &quot;speed&quot;, segments) ## Warning in regularize.values(x, y, ties, missing(ties), na.rm = na.rm): ## collapsing to unique &#39;x&#39; values speed_correlation_ogier_evans = ccf(ogier_speed_est, evans_speed_est) speed_correlation_ogier_evans ## ## Autocorrelations of series &#39;X&#39;, by lag ## ## -19 -18 -17 -16 -15 -14 -13 -12 -11 -10 -9 ## 0.111 0.140 0.072 0.065 -0.027 -0.026 0.007 -0.020 0.006 -0.087 -0.051 ## -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 ## -0.013 -0.027 -0.079 -0.010 0.015 0.080 0.273 0.487 0.929 0.509 0.328 ## 3 4 5 6 7 8 9 10 11 12 13 ## 0.080 0.030 0.036 -0.008 -0.001 0.031 -0.028 -0.167 -0.055 -0.073 -0.015 ## 14 15 16 17 18 19 ## -0.052 -0.009 0.088 0.073 0.125 0.087 We can report on the correlation at different lags by using the lag value as an index value: lag = 0 speed_correlation_ogier_evans[lag] ## ## Autocorrelations of series &#39;X&#39;, by lag ## ## 0 ## 0.929 Brake cross-correlation: ogier_brk_est = ts_estimator(trj_ogier, &quot;cum_dist&quot;, &quot;brk&quot;, segments) ## Warning in regularize.values(x, y, ties, missing(ties), na.rm = na.rm): ## collapsing to unique &#39;x&#39; values evans_brk_est = ts_estimator(trj_evans, &quot;cum_dist&quot;, &quot;brk&quot;, segments) ## Warning in regularize.values(x, y, ties, missing(ties), na.rm = na.rm): ## collapsing to unique &#39;x&#39; values ccf(ogier_brk_est, evans_brk_est) It occurs to me that if we use a high resolution sample, for example at the level of 1m, we might be able to detect consistent areas where one driver brakes sooner than another. This may be hard to spot in rally telemetry, but it may be something observable in circuit races over many laps of the same circuit. "],["validating-the-speed-model.html", "17 Validating the Speed Model", " 17 Validating the Speed Model We can use the telemetry from a route to validate (or not!) our speed model. So let’s have a go at that… We already have a stage route available, but let’s just recap how to generate that from a stage route: #stepdist = 10 #window = 20 route_convexity = get_route_convexity(stage_route_utm, stepdist, window) %&gt;% mutate(radius = curvatures(.)) %&gt;% corner_speed_model() %&gt;% acceleration_model(acc=0.1, dec=0.05) To validate the model, we need to ensure that we are testing the telemetry within the buffered route area and also ensure we are using similar sample distances. buffer_width = 50 buffered_route = get_buffered_route(stage_route_utm, buffer_width, crs=original_crs, utm=FALSE) telem_df_full_test_utm = get_full_telem(file.path(path, fn), utm=TRUE) buffered_telem_test_utm = get_route_telem(stage_route_utm, telem_df_full_test_utm) trj_buffered_test = buffered_telem_test_utm %&gt;% telemetry_full_trajectory() %&gt;% mutate(dist_into_route = dist_into_route(., stage_route_utm)) # Generate speed points at same sample distances as in speed model sample_points = route_convexity$cum_dist # Estimate based on telemetry test_speeds = ts_estimator(trj_buffered_test, &quot;cum_dist&quot;, &quot;speed&quot;, sample_points) #test_speeds = test_estimator(sample_points) # Just quickly check that the sample speed model approximates the raw data ggplot() + geom_line(data=trj_buffered_test, aes(x=dist_into_route, y=speed)) + geom_line(aes(x=sample_points, y=test_speeds), color=&#39;red&#39;, linetype = &quot;dashed&quot;) Comparing the traces, the simple estimator appears to do a reasonable job of interpolating speeds between the sample points, which means we can get a reasonable estimate of speed, from the telemetry, at any point along the route. How well does the time into stage prediction work? test_times = ts_estimator(trj_buffered_test, &quot;cum_dist&quot;, &quot;displacementTime&quot;, sample_points) ggplot() + geom_line(data=trj_buffered_test, aes(x=dist_into_route, y=displacementTime)) + geom_line(aes(x=sample_points, y=test_times), color=&#39;red&#39;, linetype = &quot;dashed&quot;) Again, that looks reasonable. Now let’s see how our simple speed model works. To begin with, how well do the speeds predicted by the speed model, based on stage route analysis, compared with speeds captured from telemetry? # Just quickly check that the sample speed model approximates the raw data ggplot() + geom_line(data=route_convexity, aes(x=cum_dist, y=acc_sp)) + geom_line(aes(x=sample_points, y=test_speeds), color=&#39;red&#39;) + geom_line(aes(x=sample_points, y=test_speeds - route_convexity$acc_sp), color=&#39;blue&#39;) We can also find a simple cross correlation between the speed model and some speed telemetry data: speed_correlation = ccf(route_convexity$acc_sp, test_speeds, na.action=na.pass) speed_correlation ## ## Autocorrelations of series &#39;X&#39;, by lag ## ## -29 -28 -27 -26 -25 -24 -23 -22 -21 -20 -19 ## -0.084 -0.079 -0.074 -0.068 -0.060 -0.049 -0.039 -0.027 -0.016 -0.002 0.011 ## -18 -17 -16 -15 -14 -13 -12 -11 -10 -9 -8 ## 0.025 0.038 0.057 0.076 0.091 0.105 0.121 0.142 0.164 0.181 0.198 ## -7 -6 -5 -4 -3 -2 -1 0 1 2 3 ## 0.220 0.242 0.265 0.290 0.318 0.347 0.378 0.404 0.432 0.466 0.500 ## 4 5 6 7 8 9 10 11 12 13 14 ## 0.531 0.555 0.567 0.560 0.543 0.523 0.496 0.461 0.420 0.383 0.349 ## 15 16 17 18 19 20 21 22 23 24 25 ## 0.316 0.287 0.260 0.234 0.211 0.185 0.161 0.145 0.135 0.126 0.114 ## 26 27 28 29 ## 0.098 0.086 0.076 0.068 The model is a bit rough, bit captures some of the major features, and gives us a crude approximation of speed. Perhpaps more important from the perspective of using the speed model as a basis for predictions of time into stage, let’s see how the time into stage prediction compares with the actual time into stage at particular locations as captured from telemetry: ggplot() + geom_line(data=route_convexity, aes(x=cum_dist, y=acc_time)) + geom_line(aes(x=sample_points, y=test_times), color=&#39;red&#39;) + geom_line(aes(x=sample_points, y=test_times - route_convexity$acc_time), color=&#39;blue&#39;) There appear to be two types of error in the prediction: a general trend component error, where the prediction appears to drift consistently from the actual time into stage as captured from telemetry; and a possible difference in “shape” of the lines. We can detrend the prediction error to get a feel how the “shape” of the predicted time drifts from the actual time. One way of detrending the data is to create a linear model of it and then inspect the residual error around that model. linear_time_model = lm((test_times - route_convexity$acc_time) ~ c(1:length(test_times))) plot(resid(linear_time_model), type=&quot;l&quot;) Another approach is to normalise the curves and then compare them: test_times_normalised = test_times / max(test_times, na.rm=T) acc_time_normalised = route_convexity$acc_time / max(route_convexity$acc_time, na.rm=T) ggplot() + geom_line(aes(x=sample_points, y=acc_time_normalised)) + geom_line(aes(x=sample_points, y=test_times_normalised), color=&#39;red&#39;) We can also compare the error between the actual times into stage and the predicted times, and the actual times into stage compared to a linear model. If the error of the predicted time into stage is less than that of the linear model, then it adds some value to time predictions based on sparse telemetry. ggplot() + geom_line(aes(x=sample_points, y=test_times_normalised - acc_time_normalised), color=&#39;blue&#39;) + geom_line(aes(x=sample_points, y=acc_time_normalised - sample_points/max(sample_points, na.rm=T)), color=&#39;red&#39;) "],["smoothing-a-route.html", "18 Smoothing a Route", " 18 Smoothing a Route If we have a route made up from a set of points, we find an smooth trajectory through them using a function such as a the smoothr::smooth() function. The trajr package also has a smoothing function in the form of TrajSmoothSG(). #smoothr_route_segment = smoothr::smooth(route_segment, # method = &quot;ksmooth&quot;) #plot(st_geometry(route_segment), col = &#39;grey&#39;, lwd = 3) #plot(st_geometry(smoothr_route_segment), # col = &quot;red&quot;, add = TRUE) However, the smoothing is based on being provided with an actual route. If we have data from multiple drivers representing multiple routes, whilst we can visualise the route as a set of points and “see” the route they tend to follow, it’s hard to see a priori how we might order those points into an approximate route given that the distance along route may vary slightly and the time along route at particular locations is also likely to vary. Thinking a bit more ecologically, we might perhaps consider a group of animals following the same (ish) path over a period of time and then trying to work out the route they take from those separate sets of sample data. How do the ecologists do that? If we know the start and end of the route are nominally at the same location, we can normalise the route length of multiple routes, map equidistant points onto each other, and then take the average. For example, this solution: https://stackoverflow.com/a/65341730/454773 . See also https://en.wikipedia.org/wiki/Dynamic_time_warping and https://dynamictimewarping.github.io/r/ . "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
