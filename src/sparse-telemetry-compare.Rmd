```{r setup_sparse_telem, warning=FALSE, include=FALSE, echo=FALSE, message=FALSE, output=FALSE}
library(knitr)
library(tidyr)
library(purrr)
library(dplyr)
library(sf)
library(lubridate)
library(ggplot2)
library(leaflet)
library(kableExtra)

library(units)

source('telemetry_tools.R')

knitr.duplicate.label = "allow"
knitr::opts_chunk$set(fig.path = "images/")
```

# Comparing Drivers' Live (Sparse) Telemetry

In this chapter, we will start to explore the extent we can compare the live telemetry data traces of different drivers. Note that te data may be quite sparse at times, which might limit what we are able to do.

Where large gaps exist between data samples, we are more likely to require a sensible time model more the stage to try to minimise errors in using a simple, linear interpolator to generate missing data.

## Load Route Data

Get the route in a UTM form:

```{r}
geojson_filename = "data/finland_2021.geojson"
geojson_sf = sf::st_read(geojson_filename)

latlon_crs = 4326

# Use a convenience function that loads in the geojson file
# and then generates a spatial features dataframe with a UTM projection
stage_route_utm = get_route(geojson_sf, 7)

stage_route_utm
```

We can lookuo the stage length in meters from the route:

```{r}
# Get the stage length.. this includes the units
stage_length_m = st_length(stage_route_utm)

stage_length = drop_units(stage_length_m)

stage_length
```

### Generate Buffered Route

We can also take this opportunity to create a buffered route for filtering the telemetry data:

```{r}
#Use a convenience function to get buffered route
buffer_width = 50
buffered_route = get_buffered_route(stage_route_utm, buffer_width,
                                    crs=original_crs, utm=FALSE)

leaflet(buffered_route) %>% 
  addProviderTiles("OpenTopoMap", group = "OSM") %>% 
  addPolylines(color = "red", weight = 2)
```

## Load Driver Data

Load in data for a handful of drivers:

```{r}
# Path to the telem data
path = "../../wrcplus/notebooks/2021_secto_Rally_Finland"
```

TO DO  - set the origin as the dummy origin

```{r}
evans_min_telem = get_min_telem("Evans", "SS7", path)
evans_min_telem_utm = evans_min_telem %>%
                        st_transform(crs = st_crs(utm_proj4_string))

# Get the buffer filtered data
route_telem_evans = get_route_telem(stage_route_utm,
                                    evans_min_telem,
                                    evans_min_telem_utm)
evans_min_telem_utm
```

We can always preview the data just to check that it is sensible:

```{r}
library(leaflet)

tmp_route <- evans_min_telem %>% st_coordinates() 

leaflet(tmp_route) %>% 
  addProviderTiles("OpenTopoMap", group = "OSM") %>% 
  addPolylines(color = "purple", weight = 5)

```

Let's get some data for some other drivers:

```{r}
fourmaux_min_telem = get_min_telem("Fourmaux", "SS7", path)

fourmaux_min_telem_utm = fourmaux_min_telem %>%
                            st_transform(crs = st_crs(utm_proj4_string))

route_telem_fourmaux = get_route_telem(stage_route_utm,
                                       fourmaux_min_telem,
                                       fourmaux_min_telem_utm)

fourmaux_min_telem_utm
```

```{r}
breen_min_telem = get_min_telem("Breen", "SS7", path)

breen_min_telem_utm = breen_min_telem %>%
                            st_transform(crs = st_crs(utm_proj4_string))

route_telem_breen = get_route_telem(stage_route_utm,
                                       breen_min_telem,
                                       breen_min_telem_utm)

route_telem_breen
```

And preview the telemetry sample points for all the drivers we have gathered telemetry data for:

```{r}
leaflet( )  %>% 
  addProviderTiles("OpenTopoMap", group = "OSM") %>% 
  addCircleMarkers(data=route_telem_evans, radius=1, color="blue") %>%
  addCircleMarkers(data=route_telem_breen, radius=1,color="red") %>%
  addCircleMarkers(data=route_telem_fourmaux, radius=1, color="black")
```

## Get Annotated Route Telemetry

The route telemetry annotation includes the distance along the stage route for each telemetry sample:

```{r}
route_telem_evans_utm = to_utm(route_telem_evans)
route_telem_evans_utm = route_telem_evans_utm %>% 
                          get_telem_dists(stage_route_utm)
#route_telem_evans_utm


route_telem_fourmaux_utm = to_utm(route_telem_fourmaux)
route_telem_fourmaux_utm = route_telem_fourmaux_utm %>% 
                          get_telem_dists(stage_route_utm)
route_telem_fourmaux_utm
```

## Create Driver Estimators

From the annotated data can generate some naive estimators for stage time along route based on distance along route:

```{r test_drivers_estimators}

fourmaux_time_estimator = approxfun(c(0, route_telem_fourmaux_utm$dist),
                           c(0, route_telem_fourmaux_utm$roundeddelta_s))

evans_time_estimator = approxfun(c(0, route_telem_evans_utm$dist),
                           c(0, route_telem_evans_utm$roundeddelta_s))

```


## Creating a Common False Time Origin

TO DO

## Visual Driver Comparison

Let's see if a visual comparison reveals anything:

```{r test_compare_driver_telem_linechart, warning=FALSE, mesage=FALSE}
# Sample every 500m
vals = seq(to=max(c(route_telem_fourmaux_utm$dist,
                    route_telem_evans_utm$dist)), by=500)

ggplot() + 
  # Predicted line in pink
  geom_line(aes(x=vals, y=evans_time_estimator(vals)), size=1, colour='blue') +
  geom_point(data=route_telem_evans_utm,
             aes(x=dist, y=roundeddelta_s), size=1, colour='red') +
  # Sampled times in black
  geom_line(aes(x=vals, y=fourmaux_time_estimator(vals)),
            color='red', size=1) +
  geom_point(data=route_telem_fourmaux_utm,
             aes(x=dist, y=roundeddelta_s), size=1, colour='blue')

```

# Finding the Time to Complete a Particular Stretch

In order to compare the time it takes two or more drivers to cover the same stretch of a stage route, we need to find out how long it takes each of them to cover that distance.

The following function will chunk the route into fixed length segments (exempt the final segment) and find out how long it taks the driver to complete that section.


```{r}
# Return time to travel along a segment. 
# Units relate to whether the distances are in eg m or km
segmentTimeDelta = function(driver_estimator, cumdist,
                                  stretch=100, units='m'){
  
  driver_estimator(cumdist+stretch) - driver_estimator(cumdist)
}
```

We can now generate a simple estimate of the time taken to complete each segment:

```{r}
#18163.4 %/% 1000 -> 18
# Get sections 1000m long
segment_length = 1000

#units = 'm'
#segment_length_m = set_units(segment_length, m)

segments = seq(from=0, to=stage_length, by = segment_length)

evans_1km_segments = segmentTimeDelta(evans_time_estimator,
                                      segments, segment_length)
evans_1km_segments
```


Let's also grab similar estimates for another driver:
    
```{r}
fourmaux_1km_segments = segmentTimeDelta(fourmaux_time_estimator,
                                         segments, segment_length)
fourmaux_1km_segments
```

# Estimatating Time Deltas Between Drivers Over Small Sections

We can now genereate a list of delta values describing the time difference between the drivers in completing each section.

__Note that if the telemetry samples are widely separated, this estimates might be quite poor, particularky if they are based on linear interpolation of times between points.__

```{r}
dummy_split_deltas = evans_1km_segments - fourmaux_1km_segments
head(dummy_split_deltas, 3)
```

If we cast the original route to a `trajr` directory, we can easily split the rout into separate sections based on the cumulative distance of step along the route.

```{r}
library(trajr)

trj <- TrajFromCoords(as.data.frame(st_coordinates(stage_route_utm)))
trj$distance = Mod(trj$displacement)
trj$cum_dist = cumsum(trj$distance)
```

We can then plot the route with the time delta highlighted:

```{r}
g = ggplot()+ coord_fixed()

# Create a trace for each segemnt
for (i in 1:length(segments)){
  start=(i-1)*segment_length
  end= start+segment_length
  
  # Filter out the part of the trajectory we want to plot
  segment_filter = trj$cum_dist >= start & trj$cum_dist <= end
  route_segment = trj[segment_filter,]
  
  # Set colour based on delta
  c= dummy_split_deltas[i]
  if (is.na(c)) c=0
  route_segment$c = c
  
  # Add segment to plot
  g = g+geom_path(data=route_segment, aes(x=x, y=y, color=c))
}

# Render plot
g+scale_colour_gradient( low = "red", high = "green", breaks=c(0)) 
```
# TO DO

TO DO  - can we split on the route using split points a distance along the route?

```{r}
# not required?
getlocation = function(route_utm, dist, units='m') {
   sample_point_sp_utm = rgeos::gInterpolate(as(route_utm, "Spatial"),
                                          dist, # Distance along route in meters
                                          normalized = FALSE)

  # We can convert back from an sp to an sf object:
  sample_point_sf_utm = st_as_sf(sample_point_sp_utm)

  # And also convert back to a latlong reference system
  sample_point_sf = sample_point_sf_utm %>% st_transform(crs = st_crs(latlon_crs))
  sample_point_sf
}

getlocation(stage_route_utm, c(1500, 2000))
```

```{r warning=FALSE}

# Not required?
df_dummy_split_points = getlocation(stage_route_utm, segments)
df_dummy_split_coords = df_dummy_split_points %>% 
                          st_coordinates() %>% 
                          as.data.frame() %>%
                          rename(lon=X, lat=Y)

df_dummy_split_coords$delta = dummy_split_deltas

head(df_dummy_split_coords, 3)
```


# Interpolation Using A Speed Model

Based on the curvature of the route, the speed model gives us a crude estimate of how long it takes to get between two points. If the route is a flat straight between the points, we'll travel 1km in much less time than if the route it tight and twisty.

The simple `approxfun()` interpolator uses a linear model to interpolate times between actual time points, but we might be able to improve interpolated estimates using a non-linear model based on a speed model generated over the route based on the route curvature. 

- identify distance into stage required (desired_d)
- find distance into stage for each
- get consecutive telemetry points between which desired distance lays (in_d, out_d, in_t, out_t)

```r
> l = c(1.1,2.1,3.1,4.1,5.1)
> c(l[findInterval(3, l)], l[findInterval(3, l)+1])
[1] 2.1 3.1
> c(l[findInterval(1, l)], l[findInterval(1, l)+1])
[1] 1.1
> c(l[findInterval(11, l)], l[findInterval(11, l)+1])
[1] 5.1  NA
```

- get speed model
- get model time at points (in_mt=model(in_d), out_mt=model(out_d), desired_mt=model(desired_d))
- get interpolated normalised model time between points, desired_nt = (desired_mt - in_mt)/(out_mt - in_mt)
- get predicted time desired_t = desired_nt*(out_t - in_t) + in_t

TO DO
