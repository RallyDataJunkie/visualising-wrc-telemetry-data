
```{r setup_load_full_telem, warning=FALSE, include=FALSE, echo=FALSE, message=FALSE, output=FALSE}
library(knitr)
library(tidyr)
library(purrr)
library(dplyr)
library(sf)
library(trajr)
library(lubridate)
library(ggplot2)

knitr.duplicate.label = "allow"
knitr::opts_chunk$set(fig.path = "images/")
```


# Full telemetry

As well as the sparse, low frequency telemetry that we can capture from the live data service whilst a stage is running, more substantial telemetry datasets are published several hours after a stage has run when the WRC onboard video views are made available.

The density of points is high enough to allow us to make a reasonable estimate on how far a car is into to the stage based simply on summing the distances between consecutive sample locations. However, this does mean that the distance metric is dependent on the actual route taken by a driver. Whilst drivers will typically take a similar line, a more exact comparison based on distance into the stage can be generated by mapping each sample location on the nearest location on the official route.

Load in the full resolution telemetry:

```{r}

get_full_telem = function (fp, proj=utm_proj4_string, utm=FALSE){
  telem_df_full_raw = read.csv(fp)  %>% drop_na("lon", "lat") %>% 
                  map_df(rev) %>%
   mutate(utc = as_datetime(utx/1000))

  # We could further tune the locations to be projections onto the route
  # This would then ensure a normalisation of the distance into the stage
  # against a common origin
  
  
  telem_df_full = telem_df_full_raw  %>%
                    st_as_sf(coords = c("lon","lat")) %>% st_set_crs(4326)

  # If required, we can get a UTM projection at this point
  if (utm) {
     telem_df_full_utm =  st_transform(telem_df_full,
                           crs = st_crs(utm_proj4_string))
     telem_df_full_utm
  } else {
    telem_df_full
  }
}

fn="df_telemetrymergeddata_SS7_Evans.csv"
telem_df_full = get_full_telem(file.path(path, fn))
```


How many data points?

```{r}
nrow(telem_df_full %>% st_coordinates() ) 
```

As we can see, the  full telemetry gives us quite closely sampled points along the route:

```{r}
leaflet(telem_df_full) %>% 
  addProviderTiles("OpenTopoMap", group = "OSM") %>% 
  addCircleMarkers(weight = 1)
```


Or how about plotting the data using ggplot:

```{r}
ggplot(data=telem_df_full) + geom_sf(aes(color=speed), size=0.1)
 
```

# Generating a `trajr` Route From the Telemetry Data

With a large number of points available, we can cast the dataset directly to a `trajr` route.

*The `trajr` R package was originally developed for use analysing animal tracks, but it's also really handy for analysing rally routes...*

```{r}
telemetry_full_trajectory = function(telem_df_full){
  
  utm_telem_full = st_transform(telem_df_full,
                                crs=utm_proj4_string) %>% 
                      mutate(lat = st_coordinates(.)[,1],
                             lon = st_coordinates(.)[,2])

  trj <- TrajFromCoords(utm_telem_full %>% select(lon, lat, utc),
                        xCol="lon", yCol="lat", timeCol="utc")
  
  # We assume that the first location is the first location on the route
  trj$distance = Mod(trj$displacement)
  
  trj$cum_dist = cumsum(trj$distance)
  
  trj$speed  = telem_df_full$speed
  trj$brk  = telem_df_full$brk
  trj$throttle  = telem_df_full$throttle
  trj$rpm  = telem_df_full$rpm

  trj
}
```


The data includes:

- `lat`/`lon` coordinates;
- a sample timestamp;
- `speed` in km/h;
- `throttle` and `brk` (*brake*) as percentage values;
- `rpm` revs;
- `accx` and `accy` acceleration forces.

If we plot these values against the distance into stage, generated from the location data and cross-referenced to the nearest point on the official stage route, we can generate a basis for comparison between different drivers.

The `trajr` route actually calculates a distance into the route assuming an origin based on the first point in the route.

```{r}

evans_fn="df_telemetrymergeddata_SS7_Evans.csv"
trj_evans = telemetry_full_trajectory(get_full_telem(file.path(path, evans_fn)))

ogier_fn="df_telemetrymergeddata_SS7_Ogier.csv"
trj_ogier = telemetry_full_trajectory(get_full_telem(file.path(path, ogier_fn)))

```

# Finding Distance into a Common Route

To provide for an exact comparison of times based on distance into stage, we can map distances onto the "official" route.

However, if the official route does not match the actual route, we may get a "false" distance measures. For example, if the "official" route starts some way along the actual route as recorded in telemetry, then we will lose information at the start of the route.

Another approach might be to generate out own unofficial official route by creating a small buffer around the intersection of the captured route telemetry and then looking up roads using OSM within that buffered area; such a road should be unique (assuming that the stage route follows tracks that appear on OpenStreetMap) and could then be used as the official route.

```{r}
dist_into_route = function(trj_utm, stage_route_utm) {
   # telem_df_full_utm =  st_transform(telem_df_full,
  #                         crs = st_crs(utm_proj4_string))
  full_pois_utm = st_sfc(st_multipoint(st_coordinates(trj_utm)),
                      crs=st_crs(trj_utm))
  full_pois_points_utm = st_cast(x = full_pois_utm, to = "POINT")
  full_pois_points_utm_sp = as(full_pois_points_utm, 'Spatial')
  
  # Find the distance along the route of the point on the route
  # nearest to each telemetry sample
  rgeos::gProject(as(stage_route_utm,"Spatial"),
                  full_pois_points_utm_sp,  normalized = FALSE)
}

trj_evans$dist_into_route = dist_into_route(trj_evans, stage_route_utm)
trj_ogier$dist_into_route = dist_into_route(trj_ogier, stage_route_utm)
```

Another approach would be simple to project one driver's route onto the route taken by a driver we are comparing them against and then finding times based distance into this common route projection.

# Looking At Braking Behaviour

Where do we brake?

```{r}
#library(ggspatial)
#  annotation_spatial(trj_ogier ) +
#  layer_spatial(trj_ogier, aes(alpha = brk), color='red',size=0.3) 

#https://github.com/eliocamp/ggnewscale
# Multiple color scales
# ?doesn't work with geom_sf which overplots?
library(ggnewscale)
ggplot() + stat_sf_coordinates(aes( color=throttle),size=0.1,
  geom = "point",
 data=trj_ogier %>% filter(throttle>0)) +
scale_color_gradient(low = "white", high = "green") +
 new_scale_color() + 
scale_color_gradient(low = "white", high = "red")+ stat_sf_coordinates( aes( color=brk), size=0.1,
  geom = "point",
  data=trj_ogier %>% filter(brk>0)
) + 
# How do we get the correct projection
#_coord_map()
# Already rectilinear...
  coord_fixed()
```



```{r}
ggplot() +
  geom_line(data=(trj_ogier %>% filter(cum_dist>=1000 & cum_dist<=2000)),
            aes(x=cum_dist,y=throttle), color='red') +
  geom_line(data=(trj_evans %>% filter(cum_dist>=1000 & cum_dist<=2000)),
            aes(x=cum_dist,y=throttle), color='blue')
```

With smoothing:

```{r}
library(zoo)

ggplot() +
  geom_line(data=trj_ogier%>% filter(cum_dist>=1000 & cum_dist<=2000) %>%
                    mutate(smooth_throttle=rollmean(throttle, k = 3, fill = NA)),
            aes(x=cum_dist,y=smooth_throttle), color='red') +
  geom_line(data=(trj_evans %>% filter(cum_dist>=1000 & cum_dist<=2000) %>%
                    mutate(smooth_throttle=rollmean(throttle, k = 3, fill = NA))),
            aes(x=cum_dist,y=smooth_throttle), color='blue')


```

We can also explore adding throttle and brake data to the speed trace.


```{r}
theme_black = function(base_size = 12, base_family = "") {
  
  theme_grey(base_size = base_size, base_family = base_family) %+replace%
    
    theme(
      # Specify axis options
      axis.line = element_blank(),  
      axis.text.x = element_text(size = base_size*0.8, color = "white", lineheight = 0.9),  
      axis.text.y = element_text(size = base_size*0.8, color = "white", lineheight = 0.9),  
      axis.ticks = element_line(color = "white", size  =  0.2),  
      axis.title.x = element_text(size = base_size, color = "white", margin = margin(0, 10, 0, 0)),  
      axis.title.y = element_text(size = base_size, color = "white", angle = 90, margin = margin(0, 10, 0, 0)),  
      axis.ticks.length = unit(0.3, "lines"),   
      # Specify legend options
      legend.background = element_rect(color = NA, fill = "black"),  
      legend.key = element_rect(color = "white",  fill = "black"),  
      legend.key.size = unit(1.2, "lines"),  
      legend.key.height = NULL,  
      legend.key.width = NULL,      
      legend.text = element_text(size = base_size*0.8, color = "white"),  
      legend.title = element_text(size = base_size*0.8, face = "bold", hjust = 0, color = "white"),  
      legend.position = "right",  
      legend.text.align = NULL,  
      legend.title.align = NULL,  
      legend.direction = "vertical",  
      legend.box = NULL, 
      # Specify panel options
      panel.background = element_rect(fill = "black", color  =  NA),  
      panel.border = element_rect(fill = NA, color = "white"),  
      panel.grid.major = element_line(color = "grey35"),  
      panel.grid.minor = element_line(color = "grey20"),  
      panel.margin = unit(0.5, "lines"),   
      # Specify facetting options
      strip.background = element_rect(fill = "grey30", color = "grey10"),  
      strip.text.x = element_text(size = base_size*0.8, color = "white"),  
      strip.text.y = element_text(size = base_size*0.8, color = "white",angle = -90),  
      # Specify plot options
      plot.background = element_rect(color = "black", fill = "black"),  
      plot.title = element_text(size = base_size*1.2, color = "white"),  
      plot.margin = unit(rep(1, 4), "lines")
      
    )
  
}
```

What happens if we try to colour the speed line accoording to the throttle and brake percentages?

```{r}
ggplot() +
  #geom_line(data=trj_ogier %>% filter(cum_dist>=1000 & cum_dist<=2000),
  #          aes(x=cum_dist,y=speed), color='white', size=4) +
   geom_line(data=trj_ogier %>% filter(cum_dist>=1000 & cum_dist<=2000),
            aes(x=cum_dist,y=speed, alpha=throttle), size=1, color="green") +
  geom_line(data=trj_ogier %>% filter(cum_dist>=1000 & cum_dist<=2000),
            aes(x=cum_dist,y=speed-3, alpha=brk), color="red", size=1) +
   geom_line(data=trj_ogier %>% filter(cum_dist>=1000 & cum_dist<=2000),
            aes(x=cum_dist,y=throttle-50, alpha=100-brk), size=1, color="green") +
  geom_line(data=trj_ogier %>% filter(cum_dist>=1000 & cum_dist<=2000),
            aes(x=cum_dist,y=brk-50, alpha=100-throttle), color="red", size=1)+
  
  theme_black()+ theme(legend.position="none")
```

```{r}
ggplot(data=telem_df_full) + geom_sf(aes(color=throttle), size=0.1)
 
```

```{r}
ggplot(data=telem_df_full) + geom_sf(aes(color=-brk), size=0.1)
 
```


# Comparing Times Into Stage


How do the times compare?

Sample common points to find the difference:

```{r}
segment_length=100

# stage_length set in earlier section
segments = seq(from=0, to=stage_length, by = segment_length)


ogier_full_estimator = approxfun(trj_ogier$cum_dist,
                            trj_ogier$displacementTime)

evans_full_estimator = approxfun(trj_evans$cum_dist,
                           trj_evans$displacementTime)

ogier_evans_point_delta = ogier_full_estimator(segments) - evans_full_estimator(segments)

# Difference in time take to reach a particular point in the stage
ggplot()+geom_line(aes(x=segments, y=ogier_evans_point_delta))
```


Compare time into stage for a given distance into stage. Note that this is the distance into the stage as calculated from the trajectory, rather than by comparison of distances into the same (idealised) route.

```{r}
ggplot() +
  geom_line(data=(trj_ogier %>% mutate(dt=as.double(displacementTime)) %>% filter(dt >=0)),
            aes(x=cum_dist,y=dt), color='blue') +
  geom_line(data=(trj_evans %>% mutate(dt=as.double(displacementTime)) %>% filter(dt >=0)),
            aes(x=cum_dist,y=dt), color='grey') 
```
